using System;
using System.ComponentModel;
using System.Text.Json;
using CommunityToolkit.Mvvm.ComponentModel;

namespace UVTQuestions.Services
{
	public partial class QuestionService : IQuestionService
	{
        private const string QuestionsPath = "[\n    {\n        \"QuestionTitle\": \"Care dintre urmatoarele afirmatii este/sunt adevarata/adevarate pentru algoritmul corespunzator functiei de mai jos (se considera ca x este un tablou unidimensional cu n elemente)?\",\n        \"Answer1\": \"Algoritmul returneaza numarul de elemente pozitive din x\",\n        \"Answer2\": \"Algoritmul returneaza numarul de elemente din cea mai lunga subsecventa cu elemente pozitive din x\",\n        \"Answer3\": \"Algoritmul are ordinul de complexitate O(n^2)\",\n        \"Answer4\": \"Algoritmul are ordinul de complexitate O(n)\",\n        \"Answer5\": \"Algoritmul are ordinul de complexitate O(n*k)\",\n        \"Answer\": \"b,d\",\n        \"Image\": \"asd_1.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre următoarele afirmaţii este/sunt adevărată/adevărate pentru algoritmul corespunzător funcţiei de mai jos (se consideră că a este un tablou unidimensional cu n elemente)?\",\n        \"Answer1\": \"Algoritmul sortează descrescător tabloul a\",\n        \"Answer2\": \"După aplicarea algoritmului, tabloul a satisface proprietatea a[i] ≥ a[n - 1] pentru 0 ≤ i < n\",\n        \"Answer3\": \"Algoritmul sortează crescător tabloul a\",\n        \"Answer4\": \"După aplicarea algoritmului, tabloul a satisface proprietatea a[i] ≤ a[n - 1] pentru 0 ≤ i < n\",\n        \"Answer\": \"b\",\n        \"Image\": \"asd_2.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră două valori naturale a şi b şi algoritmul descris prin (// specifică operatia de determinare a câtului împărtirii întregi): Care dintre următoarele afirmaţii este/sunt adevărată/adevărate?\",\n        \"Answer1\": \"Este posibil ca succesiunea de apeluri recursive să nu se termine\",\n        \"Answer2\": \"Algoritmul returnează întotdeauna 0\",\n        \"Answer3\": \"Algoritmul returnează produsul a*b dacă a este par şi a*b+b dacă a este impar\",\n        \"Answer4\": \"Algoritmul returnează produsul a*b indiferent de paritatea lui a\",\n        \"Answer5\": \"Dacă a > 2b atunci numărul de operaţii de înmulţire efectuate este mai mic în cazul apelului alg(b,a) decât în cazul apelului alg(a,b)\",\n        \"Answer\": \"d, e\",\n        \"Image\": \"asd_3.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră un tablou unidimensional, a[0..n-1], cu n = 10^10 valori numerice şi se pune problema determinării primelor 10 valori în ordine crescătoare. Care dintre următoarele abordări asigură faptul că a[0..9] conține cele mai mici 10 elemente în ordine crescătoare şi este mai eficientă?\",\n        \"Answer1\": \"Se sortează a[0..n-1] crescător folosind algoritmul quicksort\",\n        \"Answer2\": \"Se sortează parțial a aplicând algoritmul de sortare prin inserție în care ciclul exterior for i in range(1,n) se înlocuiește cu for i in range(1,11)\",\n        \"Answer3\": \"Se sortează parțial a aplicând algoritmul de sortare prin selecție în care ciclul exterior for i in range(0,n-1) se înlocuiește cu for i in range(0,10)\",\n        \"Answer\": \"c\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră algoritmul alg apelat pentru un număr natural n şi se notează cu T(n) numărul de operaţii de adunare efectuate. Care dintre următoarele afirmaţii este(sunt) adevarată(e)?\",\n        \"Answer1\": \"Algoritmul returnează câte cifre impare are numărul n\",\n        \"Answer2\": \"Algoritmul returnează numărul de cifre egale cu 1 din reprezentarea binară a lui n\",\n        \"Answer3\": \"T(n)=1 dacă n<2 şi T(n)=T([n/2])+n MOD 2 dacă n≥2\",\n        \"Answer4\": \"T(n)=0 dacă n<2 şi T(n)=T([n/2])+1 dacă n≥2\",\n        \"Answer5\": \"T(n) aparține lui O(n)\",\n        \"Answer6\": \"T(n) aparține lui O(log n)\",\n        \"Answer\": \"b,d,f\",\n        \"Image\": \"asd_5.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Algoritmul de sortare rapidă este cel mai potrivit pentru:\",\n        \"Answer1\": \"Sortarea unei liste mari cu elemente aleatoare\",\n        \"Answer2\": \"Sortarea unei liste aproape ordonate\",\n        \"Answer3\": \"Sortarea unei liste scurte\",\n        \"Answer4\": \"Nu este potrivit pentru niciun fel de sortare\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră şirul lui Fibonacci dat de relaţia de recurenţă F0 = 0, F1 = 1 şi Fn+1 = Fn + Fn-1. De câte ori este evaluat F2 pentru a calcula F5 în cazul calculului termenului Fn în mod recursiv.\",\n        \"Answer1\": \"De 3 ori\",\n        \"Answer2\": \"O dată\",\n        \"Answer3\": \"De 4 ori\",\n        \"Answer4\": \"De 5 ori\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele afirmaţii NU sunt adevărate în cazul algoritmului de căutare binară:\",\n        \"Answer1\": \"Trebuie folosit un tablou sortat\",\n        \"Answer2\": \"Trebuie să avem acces direct la elementul din mijloc\",\n        \"Answer3\": \"Algoritmul nu este eficient atunci când avem mai mult de 1000 de elemente\",\n        \"Answer4\": \"Algoritmul realizează sortarea elementelor unui tablou\",\n        \"Answer\": \"c,d\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră următorul algoritm aplicat unui număr n de forma n = ckck-1 . . . c1c0: Dacă p este o variabilă (implicită) care contorizează numărul de executări ale ciclului (contorul ciclului), care este proprietatea invariantă?\",\n        \"Answer1\": \"s = c0+c1+...+cp, n = ckck-1...cp\",\n        \"Answer2\": \"s = c0+c1+...+cp-1, n = ckck-1...cp\",\n        \"Answer3\": \"s = c0+c1+...+cp-1, n = ckck-1...c1c0\",\n        \"Answer4\": \"n = ckck-1 ...cp\",\n        \"Answer\": \"b\",\n        \"Image\": \"asd_9.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Fie A = (a1 , ..., an ) un multiset. Pentru a găsi S = (s1 , ..., sk ), un subset al lui A folosind tehnica căutarii local optimale (căutare lacomă - greedy):\",\n        \"Answer1\": \"La fiecare pas elementul care pare a fi cel mai promițător la pasul respectiv este selectat din A și adăugat la S.\",\n        \"Answer2\": \"La fiecare pas elementul care pare a fi cel mai promițător la pasul respectiv este selectat din A și adăugat la S. Dacă ulterior nu este bun îl putem înlocui cu o altă componentă.\",\n        \"Answer3\": \"La fiecare pas elementul care pare a fi cel mai promițător pe ansamblul problemei este selectat din A și adăugat la S.\",\n        \"Answer4\": \"La fiecare pas un element oarecare este selectat din A și adăugat la S.\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"O listă liniară simplu înlănţuită este:\",\n        \"Answer1\": \"Lista liniară, în care relaţia de ordonare este materializată pe suport printr-un pointer către elementul următor\",\n        \"Answer2\": \"O structură de date implementată prin tipul tablou\",\n        \"Answer3\": \"O structură de date circulară\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele afirmaţii sunt corecte?\",\n        \"Answer1\": \"Complexitatea (cea mai defavorabilă) pentru operaţiile de inserare, ştergere sau căutare într-un arbore binar de căutare este O(log n)\",\n        \"Answer2\": \"Complexitatea (cea mai defavorabilă) pentru operaţiile de inserare, ştergere sau căutare într-un arbore AVL este O(log n)\",\n        \"Answer3\": \"Complexitatea (cea mai defavorabilă) pentru operaţiile de inserare, ştergere sau căutare într-un arbore splay tree este O(log n)\",\n        \"Answer\": \"b\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Ce structură de date poate fi folosită pentru a implementa o traversare iterativă a unui arbore binar de căutare?\",\n        \"Answer1\": \"Queue\",\n        \"Answer2\": \"Stack\",\n        \"Answer3\": \"Hash Table\",\n        \"Answer4\": \"Splay tree\",\n        \"Answer\": \"b\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care este complexitatea de inserare a unui element într-o listă înlănţuită sortată?\",\n        \"Answer1\": \"O(1)\",\n        \"Answer2\": \"Θ(1)\",\n        \"Answer3\": \"O(n)\",\n        \"Answer4\": \"Θ(logn)\",\n        \"Answer\": \"c\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"O stivă este:\",\n        \"Answer1\": \"Listă liniară în care inserările se fac la un capăt al listei şi suprimările la celălalt capăt al listei\",\n        \"Answer2\": \"O listă liniară de tipul LIFO (Last In First Out)\",\n        \"Answer3\": \"O listă liniară cu restricţie la intrare\",\n        \"Answer4\": \"O listă liniară în care se manipulează mereu elementul cel mai recent introdus\",\n        \"Answer\": \"b,d\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"O structură de date de tip coadă este:\",\n        \"Answer1\": \"Structură de tip listă cu restricţie la intrare\",\n        \"Answer2\": \"O listă liniară de tipul FIFO (First In First Out)\",\n        \"Answer3\": \"O listă liniară în care toate operaţiile se efectuează doar la unul din capetele listei\",\n        \"Answer4\": \"O listă liniară în care inserările se efectuează la un capăt al listei, iar suprimările şi orice alt acces se efectuează la celălalt capăt al listei\",\n        \"Answer\": \"b,d\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"În care din următoarele structuri de date, căutarea are complexitate (worst-case) O(log n)?\",\n        \"Answer1\": \"Liste înlănţuite\",\n        \"Answer2\": \"Heap\",\n        \"Answer3\": \"Liste skip\",\n        \"Answer4\": \"Arbori splay\",\n        \"Answer\": \"c\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care din variantele de parcurgere a unui arbore binar de căutare poate fi folosită pentru afişarea tuturor nodurilor ordonate după cheia nodului.\",\n        \"Answer1\": \"Parcurgere breadth-first\",\n        \"Answer2\": \"Preordine\",\n        \"Answer3\": \"Inordine\",\n        \"Answer4\": \"Postordine\",\n        \"Answer\": \"c\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care este înălţimea minimă a unui arbore binar de căutare cu N noduri?\",\n        \"Answer1\": \"O(1)\",\n        \"Answer2\": \"O(N)\",\n        \"Answer3\": \"O(N · log2(N))\",\n        \"Answer4\": \"O(log2(N))\",\n        \"Answer\": \"d\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Care din afirmaţiile următoare sunt adevărate referitoare la operaţia de căutare într-un arbore binar de căutare cu N noduri:\",\n        \"Answer1\": \"Căutarea unui nod se face în O(log2(N)) dacă arborele este echilibrat.\",\n        \"Answer2\": \"Căutarea unui nod se face întotdeauna în O(1) dacă nodul căutat nu există.\",\n        \"Answer3\": \"Căutarea unui nod se face în (worst-case) O(N) dacă arborele nu este echilibrat.\",\n        \"Answer4\": \"Căutarea unui nod se face în O(N · log2(N)).\",\n        \"Answer\": \"a,c\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Fie următorul arbore binar de căutare, din care stergem (prin copiere) nodul 40. Care dintre următoarele afirmatii NU sunt adevărate:\",\n        \"Answer1\": \"La stergerea nodului 40, acesta va putea fi înlocuit de nodul 35\",\n        \"Answer2\": \"La stergerea nodului 40, acesta va putea fi înlocuit de nodul 37\",\n        \"Answer3\": \"La stergerea nodului 40, acesta va putea fi înlocuit de nodul 38\",\n        \"Answer4\": \"La stergerea nodului 40, acesta va putea fi înlocuit de nodul 44\",\n        \"Answer\": \"a,b\",\n        \"Image\": \"asd_21.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Fie următorul arbore binar de cautare, din care stergem (prin copiere) nodul 20. Care dintre următoarele afirmatii sunt adevărate:\",\n        \"Answer1\": \"La stergerea nodului 20, acesta va putea fi inlocuit cu nodul 12\",\n        \"Answer2\": \"La stergerea nodului 20, acesta va putea fi inlocuit cu nodul 11\",\n        \"Answer3\": \"La stergerea nodului 20, acesta va putea fi inlocuit cu nodul 23\",\n        \"Answer4\": \"La stergerea nodului 20, acesta va putea fi inlocuit cu nodul 22\",\n        \"Answer\": \"a,d\",\n        \"Image\": \"asd_22.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Fie urmatorul arbore binar. Parcurgerea in postordine corecta a acestui arbore este:\",\n        \"Answer1\": \"5,2,1,9,6,8,4,3\",\n        \"Answer2\": \"1,9,2,4,3,8,6,5\",\n        \"Answer3\": \"5,2,1,9,4,6,8,3\",\n        \"Answer4\": \"1,9,2,5,3,8,6,4\",\n        \"Answer\": \"b\",\n        \"Image\": \"asd_23.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Fie urmatorul arbore binar. Parcurgerea in inordine a acestui arbore este:\",\n        \"Answer1\": \"1,9,2,4,3,18,16,10\",\n        \"Answer2\": \"10,2,1,9,16,18,4,3\",\n        \"Answer3\": \"1,2,9,10,16,4,18,3\",\n        \"Answer4\": \"1,2,3,4,9,10,16,18\",\n        \"Answer\": \"c\",\n        \"Image\": \"asd_24.png\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Un min-heap binar este o structură de date care modelează un arbore binar aproape complet care are proprietatea de heap: Pentru orice nod N, dacă P este părintele lui N atunci cheia lui P este mai mică decât cheia lui N. Implementarea cu tablou a unui min-heap binar cu n noduri este un tablou A[0..2^m - 1] cu două atribute suplimentare: capacitatea A.length = 2^m - 1 şi mărimea A.size = n, astfel încât A.size ≤ A.length. Elementele din nodurile min-heap-ului binar sunt reţinute în primele n elemente ale lui A: rădăcina este reţinută în A[0], iar dacă N este fiul stâng (resp. drept) al unui nod P reţinut în A[i] atunci N este reţinut în A[2·i+1] (resp. A[2·i+2]). Pentru 0 ≤ i,j < n definim relaţia bunic(i,j) dacă A[j] reţine părintele părintelui nodului din A[i]. Formula ce defineşte relaţia bunic(i,j) în un min-heap binar este:\",\n        \"Answer1\": \"(4·j+3≤i)∧(i≤4·j+6)\",\n        \"Answer2\": \"(4·i+3≤j)∧(j≤4·i+6)\",\n        \"Answer3\": \"j = ⌊i/4⌋\",\n        \"Answer4\": \"(4·j+1≤i)∧(i≤4·j+2)\",\n        \"Answer5\": \"(4·i+1≤j)∧(j≤4·i+2)\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Un min-heap binar este o structură de date care modelează un arbore binar aproape complet care are proprietatea de heap: Pentru orice nod N, dacă P este părintele lui N atunci cheia lui P este mai mică decât cheia lui N. Implementarea cu tablou a unui min-heap binar cu n noduri este un tablou A[0..2^m - 1] cu două atribute suplimentare: capacitatea A.length = 2^m - 1 şi mărimea A.size = n, astfel încât A.size ≤ A.length. Elementele din nodurile min-heap-ului binar sunt reţinute în primele n elemente ale lui A: rădăcina este reţinută în A[0], iar dacă N este fiul stâng (resp. drept) al unui nod P reţinut în A[i] atunci N este reţinut în A[2·i+1] (resp. A[2·i+2]). Pentru 0 ≤ i,j < n definim relaţia bunic(i,j) dacă A[j] reţine părintele părintelui nodului din A[i]. Numărul maxim de noduri în un min-heap binar cu adâncimea h este:\",\n        \"Answer1\": \"2^(h+1) - 1\",\n        \"Answer2\": \"2^h\",\n        \"Answer3\": \"h^2 - 1\",\n        \"Answer4\": \"2^(h-1) + 1\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Un min-heap binar este o structură de date care modelează un arbore binar aproape complet care are proprietatea de heap: Pentru orice nod N, dacă P este părintele lui N atunci cheia lui P este mai mică decât cheia lui N. Implementarea cu tablou a unui min-heap binar cu n noduri este un tablou A[0..2^m - 1] cu două atribute suplimentare: capacitatea A.length = 2^m - 1 şi mărimea A.size = n, astfel încât A.size ≤ A.length. Elementele din nodurile min-heap-ului binar sunt reţinute în primele n elemente ale lui A: rădăcina este reţinută în A[0], iar dacă N este fiul stâng (resp. drept) al unui nod P reţinut în A[i] atunci N este reţinut în A[2·i+1] (resp. A[2·i+2]). Pentru 0 ≤ i,j < n definim relaţia bunic(i,j) dacă A[j] reţine părintele părintelui nodului din A[i]. (1) Dacă A este un min-heap binar atunci A este sortat în ordinea crescătoare a cheilor din noduri? (2) Dacă A este sortat în ordinea crescătoare a cheilor din noduri atunci A este un min-heap binar?\",\n        \"Answer1\": \"(1) fals (2) adevărat\",\n        \"Answer2\": \"(1) fals (2) fals\",\n        \"Answer3\": \"(1) adevărat (2) adevărat\",\n        \"Answer4\": \"(1) adevărat (2) fals\",\n        \"Answer\": \"a\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Un min-heap binar este o structură de date care modelează un arbore binar aproape complet care are proprietatea de heap: Pentru orice nod N, dacă P este părintele lui N atunci cheia lui P este mai mică decât cheia lui N. Implementarea cu tablou a unui min-heap binar cu n noduri este un tablou A[0..2m - 1] cu două atribute suplimentare: capacitatea A.length = 2m - 1 şi mărimea A.size = n, astfel încât A.size ≤ A.length. Elementele din nodurile min-heap-ului binar sunt reţinute în primele n elemente ale lui A: rădăcina este reţinută în A[0], iar dacă N este fiul stâng (resp. drept) al unui nod P reţinut în A[i] atunci N este reţinut în A[2·i+1] (resp. A[2·i+2]). Pentru 0 ≤ i,j < n definim relaţia bunic(i,j) dacă A[j] reţine părintele părintelui nodului din A[i]. Timpul de execuţie a operaţiei de ştergere a nodului cu cheie minimă din un min-heap binar cu n noduri este:\",\n        \"Answer1\": \"O(1)\",\n        \"Answer2\": \"O(logn)\",\n        \"Answer3\": \"Θ(nlogn)\",\n        \"Answer4\": \"Θ(n)\",\n        \"Answer\": \"b\",\n        \"Category\": \"Algoritmi si structuri de date\"\n    },\n    {\n        \"QuestionTitle\": \"Se dau mulţimile A = {a,b,c}, B = {A,B,C,D} şi C = {1,2,3,4,5}. Câte submulţimi ale mulţimii A U B U C conţin un element din A, două din B şi cel puţin 4 elemente din C?\",\n        \"Answer1\": \"15\",\n        \"Answer2\": \"14\",\n        \"Answer3\": \"100\",\n        \"Answer4\": \"108\",\n        \"Answer\": \"d\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Câte numere întregi cuprinse între 1 şi 1000 se divid cu 7, dar nu se divid cu 3?\",\n        \"Answer1\": \"93\",\n        \"Answer2\": \"95\",\n        \"Answer3\": \"92\",\n        \"Answer4\": \"136\",\n        \"Answer\": \"b\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"În câte feluri putem forma un buchet cu cinci trandafiri dacă putem folosi trandafiri roşii, galbeni şi albi? Ordinea punerii trandafirilor în buchet nu este relevantă.\",\n        \"Answer1\": \"21\",\n        \"Answer2\": \"120\",\n        \"Answer3\": \"125\",\n        \"Answer4\": \"243\",\n        \"Answer5\": \"15\",\n        \"Answer\": \"a\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Un mesaj transmis pe un canal de comunicare este o secvenţă de 2 tipuri de semnale: semnale de tip A care durează 1 microsecundă, şi semnale de tip B care durează 2 microsecunde. De exemplu, mesajul ABAAB durează 3 x 1 + 2 x 2 = 7 microsecunde. Fie an numărul de mesaje diferite care durează n microsecunde. Care este valoarea lui a10?\",\n        \"Answer1\": \"89\",\n        \"Answer2\": \"55\",\n        \"Answer3\": \"2917\",\n        \"Answer4\": \"144\",\n        \"Answer\": \"a\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"In internet, format din reţele interconectate de calculatoare, fiecărei conexiuni de reţea dintr-un calculator i se atribuie o adresă internet. Protocolul IPv4 prevede că o adresă internet este un şir de 32 biţi, format din un număr de reţea (netid) urmat de un număr de gazdă (hostid). Sunt 3 tipuri de adrese internet: (vezi imagine). Câte adrese IPv4 diferite sunt disponibile pentru conexiunile de reţea din internet?\",\n        \"Answer1\": \"2^29 ·2^30 ·2^31\",\n        \"Answer2\": \"2^31\",\n        \"Answer3\": \"7·2^29\",\n        \"Answer4\": \"2^32\",\n        \"Answer\": \"c\",\n        \"Image\": \"tgc_5.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Fie reţeaua de transport G cu sursa s şi destinaţia t: (vezi imagine). Care este valoarea fluxului maxim în G?\",\n        \"Answer1\": \"8\",\n        \"Answer2\": \"5\",\n        \"Answer3\": \"6\",\n        \"Answer4\": \"7\",\n        \"Answer\": \"d\",\n        \"Image\": \"tgc_6.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Fie graful ponderat: (vezi imagine). Ce greutate totală are arborele minim de acoperire al acestui graf?\",\n        \"Answer1\": \"229\",\n        \"Answer2\": \"216\",\n        \"Answer3\": \"230\",\n        \"Answer4\": \"234\",\n        \"Answer\": \"a\",\n        \"Image\": \"tgc_7.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Care din grafurile următoare este eulerian?\",\n        \"Answer1\": \"G1,G4\",\n        \"Answer2\": \"G2,G3\",\n        \"Answer3\": \"niciunul\",\n        \"Answer4\": \"G4\",\n        \"Answer5\": \"G1,G3\",\n        \"Answer\": \"b\",\n        \"Image\": \"tgc_8.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Care din grafurile următoare are un cuplaj perfect?\",\n        \"Answer1\": \"G1\",\n        \"Answer2\": \"G2\",\n        \"Answer3\": \"G3\",\n        \"Answer4\": \"G4\",\n        \"Answer5\": \"216\",\n        \"Answer\": \"a\",\n        \"Image\": \"tgc_9.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Câţi arbori diferiţi cu 5 noduri, numerotate de la 1 la 5, există?\",\n        \"Answer1\": \"10\",\n        \"Answer2\": \"273\",\n        \"Answer3\": \"32\",\n        \"Answer4\": \"120\",\n        \"Answer5\": \"125\",\n        \"Answer\": \"e\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Câte cuplaje maxime are graful bipartit complet Km,n dacă 1 ≤ m ≤ n? Observaţi că un astfel de cuplaj trebuie să aibe m muchii.\",\n        \"Answer1\": \"m\",\n        \"Answer2\": \"m+n\",\n        \"Answer3\": \"P(n,m)\",\n        \"Answer4\": \"C(n,m)\",\n        \"Answer5\": \"m^n\",\n        \"Answer6\": \"n^m\",\n        \"Answer\": \"c\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Câte muchii are graful complet Kn?\",\n        \"Answer1\": \"C(n,2)\",\n        \"Answer2\": \"n^2\",\n        \"Answer3\": \"2^n\",\n        \"Answer4\": \"n·(n-1)\",\n        \"Answer5\": \"n\",\n        \"Answer\": \"a\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Se presupune că n ≥ 3. Câte regiuni are o reprezentare planară a grafului bipartit complet Kn,2?\",\n        \"Answer1\": \"n+1\",\n        \"Answer2\": \"n\",\n        \"Answer3\": \"2·n\",\n        \"Answer4\": \"C(n,2)\",\n        \"Answer5\": \"P(n,2)\",\n        \"Answer\": \"b\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Un şir ternar este un şir care conţine doar cifrele 0,1 şi 2. Fie an numărul şirurilor ternare de lungime n care nu conţin apariţii consecutive ale cifrei 0. De exemplu, a1 = 3 şi a2 = 8. Care din formulele următoare are loc pentru orice n ≥ 3:\",\n        \"Answer1\": \"an =2an-1 +2an-2\",\n        \"Answer2\": \"an =2an-1 +2an-2 +3^(n-1)\",\n        \"Answer3\": \"an =2an-1 +3an-2\",\n        \"Answer4\": \"an =2an-1 +3^(n-1)\",\n        \"Answer\": \"a\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre grafurile următoare au numărul cromatic 2:\",\n        \"Answer1\": \"Orice arbore cu n ≥ 2 noduri.\",\n        \"Answer2\": \"Orice graf complet Kn cu număr par de noduri.\",\n        \"Answer3\": \"Orice graf complet Kn cu număr impar de noduri mai mare sau egal ca 3.\",\n        \"Answer4\": \"Orice graf ciclic Cn cu n ≥ 2 număr par.\",\n        \"Answer5\": \"Orice graf ciclic Cn cu n ≥ 2 număr impar.\",\n        \"Answer6\": \"Orice graf bipartit Km,n.\",\n        \"Answer\": \"a,d,f\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"A⊕B = C ∈ Mn dacă C[i][j] = max(A[i][j],B[i][j]) şi A⊙k B = D ∈ Mn dacă D[i][j] = A[i][k] · B[k][j]. Fie G un graf simplu neorientat cu n noduri numerotate de la 1 la n, şi AG ∈ Mn matricea lui de adiacenţă. Numărul de grafuri neorientate simple cu n noduri numerotate de la 1 la n este:\",\n        \"Answer1\": \"2^(n*(n-1)/2\",\n        \"Answer2\": \"2^n\",\n        \"Answer3\": \"n(n-1)/2\",\n        \"Answer4\": \"n-1\",\n        \"Answer5\": \"n·(n-1)\",\n        \"Answer\": \"a\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Fie Mn mulţimea matricilor de dimensiune n x n cu elemente 0 sau 1. Pentru orice două matrici A, B ∈ Mn şi 1 ≤ k ≤ n definim operaţiile A ⊕ B şi A ⊙k B în felul următor: A ⊕ B = C ∈ Mn dacă C[i][j] = max(A[i][j], B[i][j]) şi A ⊙k B = D ∈ Mn dacă D[i][j] = A[i][k] · B[k][j] pentru toţi 1 ≤ i, j ≤ n.Fie G un graf simplu neorientat cu n noduri numerotate de la 1 la n, şi AG ∈ Mn matricea lui de adiacenţă. Fie In matricea identitate de dimensiune n x n, şi 1 ≤ p ≤ n. Se consideră algoritmul următor de calcul al matricii B ∈ Mn\",\n        \"Answer1\": \"Θ(p·n^2)\",\n        \"Answer2\": \"Θ(p·n)\",\n        \"Answer3\": \"Θ(p·n^3)\",\n        \"Answer4\": \"Θ(n),Θ(p·2^n)\",\n        \"Answer\": \"a\",\n        \"Image\": \"tgc_17.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Fie Mn mulţimea matricilor de dimensiune n x n cu elemente 0 sau 1. Pentru orice două matrici A, B ∈ Mn şi 1 ≤ k ≤ n definim operaţiile A ⊕ B şi A ⊙k B în felul următor: A ⊕ B = C ∈ Mn dacă C[i][j] = max(A[i][j], B[i][j]) şi A ⊙k B = D ∈ Mn dacă D[i][j] = A[i][k] · B[k][j] pentru toţi 1 ≤ i, j ≤ n. Fie G un graf simplu neorientat cu n noduri numerotate de la 1 la n, şi AG ∈ Mn matricea lui de adiacenţă. Fie In matricea identitate de dimensiune n x n, şi 1 ≤ p ≤ n. Se consideră algoritmul următor de calcul al matricii B ∈ Mn\",\n        \"Answer1\": \"Există o cale de lungime cel mult p + 1 de la nodul i la nodul j.\",\n        \"Answer2\": \"Există o cale de lungime p de la nodul i la nodul j\",\n        \"Answer3\": \"Există o cale de la nodul i la nodul j care trece prin nodul p.\",\n        \"Answer4\": \"Există o cale de la nodul i la nodul j care trece prin toate nodurile din mulţimea {1, 2, . . . , p}.\",\n        \"Answer\": \"a\",\n        \"Image\": \"tgc_18.png\",\n        \"Category\": \"Teoria grafurilor si combinatorica\"\n    },\n    {\n        \"QuestionTitle\": \"Consideraţi, în logica predicatelor, limbajul care conţine următoarele simboluri: (vezi imagine) Care din următoarele sunt termeni peste acest limbaj?\",\n        \"Answer1\": \"(0*x)-1\",\n        \"Answer2\": \"1+(z*x)<0\",\n        \"Answer3\": \"x+((-1)*0)\",\n        \"Answer4\": \"0*(y+1)\",\n        \"Answer\": \"c,d\",\n        \"Image\": \"lc_1.png\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Pentru următoarele formule propoziţionale, şi pentru interpretarea {P, ¬Q}:\",\n        \"Answer1\": \"((P ⇒ Q) ∧ ((¬Q) ∧ P )) are valoarea sub interpretare A\",\n        \"Answer2\": \"((P ⇒ Q) ⇒ (Q ⇒ P )) are valoarea sub interpretare A\",\n        \"Answer3\": \"((¬(P v Q)) ∧ (¬Q)) are valoarea sub interpretare F .\",\n        \"Answer\": \"b,c\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele afirmaţii este adevărată:\",\n        \"Answer1\": \"dacă o formulă propoziţională este validă, atunci este satisfiabilă\",\n        \"Answer2\": \"dacă o formulă propoziţională nu este validă, atunci este nesatisfiabilă\",\n        \"Answer3\": \"dacă o formulă propoziţională nu este validă, atunci negaţia sa este satisfiabilă\",\n        \"Answer4\": \"dacă o formulă propoziţională nu este validă, atunci negaţia sa este validă\",\n        \"Answer\": \"a,c\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Care este relaţia dintre propoziţiile (F ∧ G) ⇒ H şi F ⇒ (G ⇒ H)?\",\n        \"Answer1\": \"sunt logic echivalente\",\n        \"Answer2\": \"prima este o consecinţă logică a celei de-a doua\",\n        \"Answer3\": \"a doua este o consecinţă logică a primeia\",\n        \"Answer4\": \"nu se relaţionează în niciun fel descris mai sus\",\n        \"Answer\": \"a,b,c\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Formula P⇔Q este: ... aceste formule fiind: Q ⇒ R, R ⇒ (P ∧ Q), P ⇒(QvR).\",\n        \"Answer1\": \"logic echivalentă cu conjuncţia formulelor de mai jos\",\n        \"Answer2\": \"o consecinţă logică a formulelor de mai jos\",\n        \"Answer3\": \"logic echivalentă cu disjuncţia formulelor de mai jos\",\n        \"Answer\": \"b\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Care din formulele de mai jos sunt în formă normală disjunctivă?\",\n        \"Answer1\": \"P\",\n        \"Answer2\": \"¬P v Q\",\n        \"Answer3\": \"P ∧ ¬Q ∧ S\",\n        \"Answer4\": \"(P ∧¬Q∧S)v¬S\",\n        \"Answer\": \"a,b,c,d\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele este un rezolvent al clauzelor {P, ¬Q, R} şi {¬P, Q, S}?\",\n        \"Answer1\": \"∅\",\n        \"Answer2\": \"{P,¬P,R,S}\",\n        \"Answer3\": \"{R,S}\",\n        \"Answer\": \"b\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Pentru a verifica faptul că o formulă G este o consecinţă logică a formulelor F1, . . . , Fn, se poate:\",\n        \"Answer1\": \"verifica dacă (F1 ∧ . . . ∧ Fn) ⇒ G este nesatisfiabilă\",\n        \"Answer2\": \"verifica dacă ¬F1 v . . . v ¬Fn v G este nesatisfiabilă\",\n        \"Answer3\": \"verifica dacă ¬F1 v ... v¬Fn v G este validă\",\n        \"Answer4\": \"verifica dacă F1 ∧ . . . ∧ Fn ∧ ¬G este nesatisfiabilă\",\n        \"Answer\": \"c,d\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Există o formulă logic echivalenta cu (vezi imagine) care conţine doar conectori propoziţionali din mulţimea: ..(vezi raspunsuri)... unde | este conectorul NŞI (i.e. P |Q = ¬(P ∧ Q)).\",\n        \"Answer1\": \"{¬,v}\",\n        \"Answer2\": \"{v,∧}\",\n        \"Answer3\": \"{|}\",\n        \"Answer4\": \"{⊥,→}\",\n        \"Answer\": \"a,d,f\",\n        \"Image\": \"lc_9.png\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Mulţimea de clauze ce corespunde formulei (¬P ⇒(Q∧R))⇒(P ⇒¬Q) este:\",\n        \"Answer1\": \"{{¬P,¬Q}}\",\n        \"Answer2\": \"{{P,¬Q},{P,R},{¬Q,R}}\",\n        \"Answer3\": \"{{P,¬Q,¬R},{P,Q,R},{¬P,¬Q,R}}\",\n        \"Answer\": \"a\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Consideraţi mulţimea de clauze: (1) {P, Q, ¬R}, (2) {¬P, R}, (3) {P, ¬Q, S}, (4) {¬P, ¬Q, ¬R}, (5) {P,¬S}. Formula corespunzătoare acestei mulţimi este:\",\n        \"Answer1\": \"validă\",\n        \"Answer2\": \"satisfiabilă\",\n        \"Answer3\": \"nesatisfiabilă\",\n        \"Answer\": \"b\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Metoda Davis-Putnam returnează răspunsul satisfiabil:\",\n        \"Answer1\": \"când se generează clauza vidă\",\n        \"Answer2\": \"când se generează mulţimea vidă de clauze\",\n        \"Answer3\": \"când nu se pot genera clauze noi, şi clauza vidă nu este în mulţimea de clauze\",\n        \"Answer\": \"b,c\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Pentru a demonstra o formulă G când se cunoaşte o disjuncţie A v B:\",\n        \"Answer1\": \"se presupune A şi se demonstrează G, apoi se presupune B şi se demonstrază G\",\n        \"Answer2\": \"se presupune A şi se demonstrează G\",\n        \"Answer3\": \"se presupune ¬A şi se demonstrează B şi G\",\n        \"Answer\": \"a\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Fie P,Q,R variabile propoziţionale. Care din formulele propoziţionale de mai jos corespund funcţiei booleene cu trei argumente care returnează A dacă argumentele sale reprezintă codificarea binară a unui număr prim este:\",\n        \"Answer1\": \"P ∧ Q ∧ ¬R\",\n        \"Answer2\": \"(¬P ∧Q)v(P ∧R)\",\n        \"Answer3\": \"(¬P ∧Q∧¬R)v(((¬P ∧Q)vP)∧R)\",\n        \"Answer4\": \"((¬P ∧Q)v(P ∧¬Q)v(P ∧Q))\",\n        \"Answer\": \"b,c\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Fie mulţimea de clauze: {{¬P, ¬Q, R}, {P, ¬Q, ¬R}, {¬P, R}, {P, ¬Q, R}, {¬Q, ¬R}} . Primul pas în aplicarea metodei Davis Putnam asupra mulţimii de clauze consistă în: \",\n        \"Answer1\": \"aplicarea regulii de împărţire (folosind literalul ¬P );\",\n        \"Answer2\": \"aplicarea regulii literalului pur (unde literalul pur este ¬Q);\",\n        \"Answer3\": \"aplicarea unui pas de rezoluţie;\",\n        \"Answer4\": \"aplicarea regulii clauzei cu un singur literal (folosind ultima clauză).\",\n        \"Answer\": \"b\",\n        \"Category\": \"Logica Computationala\"\n    },\n    {\n        \"QuestionTitle\": \"Limbajul generat de gramatica G = (VN,VT,S,P), unde VN = {S}; VT = {a,b}; P = {S → aSb|aAb, A → aA|λ}, este:\",\n        \"Answer1\": \"L={a^mb^n|m≥n≥1,}\",\n        \"Answer2\": \"L = {a^na^mb^n|n ≥ 0,m ≥ 0}\",\n        \"Answer3\": \"L = {a^(i+1)b^i|i ≥ 1}\",\n        \"Answer4\": \"L = {a^(n+i)bn|n ≥ 1,i ≥ 0}\",\n        \"Answer\": \"a,d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Regulile gramaticii G = (VN,VT,S,P), unde VN = {S}, VT = {PCR,PDAR,UDMR}, P = {S → PCR|PDAR|UDMR}, respectă restricţiile impuse gramaticilor:\",\n        \"Answer1\": \"regulate (tip 3)\",\n        \"Answer2\": \"independente de context (tip 2)\",\n        \"Answer3\": \"dependente de context (tip 1)\",\n        \"Answer4\": \"de tipul 0, 1, 2, 3\",\n        \"Answer\": \"a,b,c,d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Regulile gramaticii G = (VN,VT,S,P), unde P = {S → abc|aAbc, Ab → bA, Ac → Bbcc, bB → Bb, aB → aaA|aa}, respectă restricţiile impuse gramaticilor:\",\n        \"Answer1\": \"regulate (tip 3)\",\n        \"Answer2\": \"independente de context (tip 2)\",\n        \"Answer3\": \"dependente de context (tip 1)\",\n        \"Answer4\": \"de tipul 0\",\n        \"Answer\": \"d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Expresia regulată ce notează limbajul L = {w| şiruri de 0 şi 1 ce conţin cel putin un simbol 1 }, este:\",\n        \"Answer1\": \"(0|1)*1\",\n        \"Answer2\": \"1|(0|1)*1(1|0)*\",\n        \"Answer3\": \"0*11*\",\n        \"Answer4\": \"(0|1)*1(0|1)*\",\n        \"Answer\": \"b,d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Limbajul L notat de expresia regulata 01*|1; este:\",\n        \"Answer1\": \"L = {0,1,00,01,10,11,000,...}\",\n        \"Answer2\": \"L={w∈{0,1}*|w începe cu 1}\",\n        \"Answer3\": \"L={w∈{0,1}*|w începe cu 0}\",\n        \"Answer4\": \"L = {01^n|n ≥ 0} S{1}\",\n        \"Answer\": \"d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Limbajul L notat de expresia regulata (1|0)*0(0|1) este:\",\n        \"Answer1\": \"L = {0,1,00,01,10,11,...}\",\n        \"Answer2\": \"L={w∈{0,1}*|w se termină cu 00 sau 01}\",\n        \"Answer3\": \"L = {w ∈ {0,1}*|w are cel putin un simbol 0 }\",\n        \"Answer4\": \"L = {w ∈ {0, 1}*|w are 0 în penultima poziţie }\",\n        \"Answer\": \"b,d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Dacă L1 este un limbaj regulat iar despre L2 nu se cunoaşte tipul dar L1 / L2 este regulat, atunci L2 poate să fie\",\n        \"Answer1\": \"mulţimea vidă\",\n        \"Answer2\": \"independente de context\",\n        \"Answer3\": \"decidabil\",\n        \"Answer4\": \"regulat\",\n        \"Answer\": \"a,b,d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Aplicând Lema de pompare pentru un limbaj regulat, considerăm un cuvânt w suficient de lung care aparţine limbajului L şi îl descompunem în . . . . . . părţi.\",\n        \"Answer1\": \"2\",\n        \"Answer2\": \"5\",\n        \"Answer3\": \"3\",\n        \"Answer4\": \"6\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"O producţie de forma A → B, unde A şi B nu sunt terminale, se numeşte\",\n        \"Answer1\": \"Regulă de ştergere\",\n        \"Answer2\": \"Redenumire\",\n        \"Answer3\": \"Formă normală Greibach\",\n        \"Answer4\": \"Formă normală Chomsky\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Orice gramatică în formă normală Chomsky este\",\n        \"Answer1\": \"regulată\",\n        \"Answer2\": \"dependentă de context\",\n        \"Answer3\": \"independentă de context\",\n        \"Answer4\": \"toate cele menţionate anterior\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre producţiile de mai jos poate fi acceptată de gramatica în formă normală Chomsky, unde A, B, C şi S sunt neterminale iar a este terminal?\",\n        \"Answer1\": \"A→BC\",\n        \"Answer2\": \"A → a\",\n        \"Answer3\": \"S → λ\",\n        \"Answer4\": \"toate cele menţionate anterior\",\n        \"Answer\": \"d\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre următoarele seturi de reguli corespund unei gramatici în formă normală Chomsky?\",\n        \"Answer1\": \"A→AB|BC|CD,A→0,B→1,C→2,D→3\",\n        \"Answer2\": \"A → AB, S → BCA|0|1|2|3\",\n        \"Answer3\": \"S→ABa,A→aab,B→Ac\",\n        \"Answer4\": \"toate cele menţionate anterior\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Fie L limbajul generat de gramatica G = (VN,VT,S,P) unde VN = {S,A,B,C,X,Y,Z}, VT = {a, b, c}, şi P = { S → λ | AX | BY | CZ, X → λ | BY | CZ, Y → λ | AX | CZ, Z → λ | AX | BY, A → a, B → b, C → c}. Alegeţi răspunsurile corecte.\",\n        \"Answer1\": \"L este limbaj regulat\",\n        \"Answer2\": \"L nu este limbaj regulat\",\n        \"Answer3\": \"L este limbaj de programare\",\n        \"Answer4\": \"\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Fie L limbajul generat de gramatica G = (VN,VT,S,P) unde VN = {S,A,B,C,X,Y,Z}, VT = {a, b, c}, şi P = { S → λ | AX | BY | CZ, X → λ | BY | CZ, Y → λ | AX | CZ, Z → λ | AX | BY, A → a, B → b, C → c}. Care din afirmaţiile următoare este adevărată?\",\n        \"Answer1\": \"L = {w ∈ VT* | w nu conţine litere consecutive identice}\",\n        \"Answer2\": \"L = {w ∈ VT*| w conţine litere consecutive identice}\",\n        \"Answer3\": \"L = {w ∈ VT* | w conţine subşirul abc}\",\n        \"Answer4\": \"L = {λ}.\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Fie L limbajul generat de gramatica G = (VN,VT,S,P) unde VN = {S,A,B,C,X,Y,Z}, VT = {a, b, c}, şi P = { S → λ | AX | BY | CZ, X → λ | BY | CZ, Y → λ | AX | CZ, Z → λ | AX | BY, A → a, B → b, C → c}. Fie sn numărul şirurilor din L cu lungimea n. Pentru orice n > 1 are loc relaţia de recurenţă:\",\n        \"Answer1\": \"sn = 2·sn-1\",\n        \"Answer2\": \"sn = 3·sn-1\",\n        \"Answer3\": \"sn = sn-1 +2·sn-2\",\n        \"Answer4\": \"sn = 3 sn-1 + sn-2\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Fie L limbajul generat de gramatica G = (VN,VT,S,P) unde VN = {S,A,B,C,X,Y,Z}, VT = {a, b, c}, şi P = { S → λ | AX | BY | CZ, X → λ | BY | CZ, Y → λ | AX | CZ, Z → λ | AX | BY, A → a, B → b, C → c}. Câte şiruri cu lungimea 4 conţine L?\",\n        \"Answer1\": \"16\",\n        \"Answer2\": \"24\",\n        \"Answer3\": \"32\",\n        \"Answer4\": \"81\",\n        \"Answer5\": \"243\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbaje formale şi teoria automatelor\"\n    },\n    {\n        \"QuestionTitle\": \"Ce afisează următoarea secventă de cod?\",\n        \"Answer1\": \"45 4\",\n        \"Answer2\": \"51 10\",\n        \"Answer3\": \"Eroare la executie deoarece variabila y nu este definită\",\n        \"Answer4\": \"Eroare la compilare deoarece functia este apelată fără argumente\",\n        \"Answer5\": \"None\",\n        \"Answer\": \"a\",\n        \"Image\": \"py_1.png\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Considerând secventa de cod: s = ''Timisoara'' Care dintre secventele de cod de mai jos returnează sirul de caractere 'aom'?\",\n        \"Answer1\": \"s[::-3]\",\n        \"Answer2\": \"s[::2]\",\n        \"Answer3\": \"s[-1:3:1]\",\n        \"Answer4\": \"[i for i in s if i in 'aom']\",\n        \"Answer5\": \"''.join([i for i in s if i in 'aom'])\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Care este valoarea expresiei: 1 + 2 ** 3 * 4\",\n        \"Answer1\": \"33\",\n        \"Answer2\": \"4097\",\n        \"Answer3\": \"36\",\n        \"Answer4\": \"108\",\n        \"Answer5\": \"42\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Este sigur să folosim operatorul == pentru a verifica dacă două variabile de tip float sunt egale?\",\n        \"Answer1\": \"Nu deoarece reprezentarea internă a valorilor de tip float nu este precisă\",\n        \"Answer2\": \"Da, bineînțeles\",\n        \"Answer3\": \"Nu, operatorul pentru comparație este !=\",\n        \"Answer4\": \"Da, deoarece reprezentarea în virgulă mobilă asigură precizia necesară\",\n        \"Answer5\": \"Da, Python asigură aproximările necesare comparării valorilor de tip float\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre opțiunile de mai jos reprezintă o inițializare corectă a unui dicționar?\",\n        \"Answer1\": \"d = ('nume': 'valoare')\",\n        \"Answer2\": \"d = 'nume': 'valoare'\",\n        \"Answer3\": \"d = {'nume':'valoare'}\",\n        \"Answer4\": \"d = ['nume'='valoare']\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Care este rezultatul execuției următoarei secvențe de cod?\",\n        \"Answer1\": \"11\",\n        \"Answer2\": \"12\",\n        \"Answer3\": \"21\",\n        \"Answer4\": \"22\",\n        \"Answer5\": \"33\",\n        \"Answer\": \"b\",\n        \"Image\": \"py_6.png\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Fie următoarea secvență de cod: (vezi imagine) Cum putem apela metoda salut() din clasa Persoana?\",\n        \"Answer1\": \"Persoana.salut(prof1)\",\n        \"Answer2\": \"prof1.salut()\",\n        \"Answer3\": \"super(prof1).salut()\",\n        \"Answer4\": \"Persoana(prof1).salut()\",\n        \"Answer5\": \"Nu putem apela metoda salut() din clasa Persoana deoarece este supraîncărcată în clasa Profesor\",\n        \"Answer\": \"a,d\",\n        \"Image\": \"py_7.png\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Care este rezultatul execuției următoarei secvențe de cod?\",\n        \"Answer1\": \"Doar metoda __init__ din clasa B este invocată\",\n        \"Answer2\": \"Metoda __init__ din clasa A este invocată și se afișează 'i from B is 0'.\",\n        \"Answer3\": \"Metoda __init__ din clasa A este invocată și se afișează 'i from B is 60'.\",\n        \"Answer4\": \"Metoda __init__ din clasa A este invocată și se afișează 'i from B is 90'.\",\n        \"Answer\": \"d\",\n        \"Image\": \"py_8.png\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Când este executată clauza finally dintr-un bloc try:   except:\",\n        \"Answer1\": \"când nu are loc nicio excepție\",\n        \"Answer2\": \"când are loc o excepție\",\n        \"Answer3\": \"tot timpul\",\n        \"Answer4\": \"doar dacă o anumită condiție specificată este îndeplinită\",\n        \"Answer5\": \"niciodată\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre variantele de mai jos deschide un fișier pentru scriere?\",\n        \"Answer1\": \"output_file = open('hello.txt', 'r')\",\n        \"Answer2\": \"output_file = open('hello.txt', 'w')\",\n        \"Answer3\": \"output_file = openFile('hello.txt', 'w')\",\n        \"Answer4\": \"output_file = File('hello.txt', 'w')\",\n        \"Answer5\": \"output_file = open(''hello.txt'', encoding=''utf8'')\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbajul Python\"\n    },\n    {\n        \"QuestionTitle\": \"Fie următoarea secvență de cod: #define swap(a,b) {int aux; aux=a; a=b; b=aux;} float x=10.5, y=3.75; în urma apelului swap(x, y); valorile variabilelor x, respectiv y vor fi:\",\n        \"Answer1\": \"x=3.75, y=10.5\",\n        \"Answer2\": \"x=3.0, y=10.5\",\n        \"Answer3\": \"x=3.75, y=10.0\",\n        \"Answer4\": \"x=3.0, y=10.0\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Ce reprezintă domeniul de vizibilitate a unei variabile?\",\n        \"Answer1\": \"plaja de valori pe care le poate lua\",\n        \"Answer2\": \"locul unde se creează\",\n        \"Answer3\": \"locul din textul sursă unde poate fi folosită\",\n        \"Answer4\": \"dacă are semn sau nu\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"La execuţia programului următor se tastează 20. Ce se va afişa după execuţie? #include <stdio.h>\\nvoid main() {\\nchar a; scanf(\\\"%c\\\",&a); printf(\\\"%c\\\",a); }\",\n        \"Answer1\": \"20\",\n        \"Answer2\": \"2\",\n        \"Answer3\": \"0\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Care este rezultatul numeric al evaluării expresiei: a<b<c dacă a=-2, b=-1 si c=0?\",\n        \"Answer1\": \"1\",\n        \"Answer2\": \"TRUE\",\n        \"Answer3\": \"0\",\n        \"Answer4\": \"FALSE\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Ce se va afişa în urma execuţiei secvenţei următoare: #include <stdio.h>\\nvoid main() { unsigned char x=25; x=x<<2; printf(\\\"%d\\\",(int)x); }\",\n        \"Answer1\": \"27\",\n        \"Answer2\": \"100\",\n        \"Answer3\": \"23\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Ce afişează programul? #include <stdio.h>\\nvoid main() { int x,y,z; x=y=z=4; printf(\\\"%d\\\",(x<<z)-(x|y)+(z&y));}\",\n        \"Answer1\": \"64\",\n        \"Answer2\": \"4\",\n        \"Answer3\": \"0\",\n        \"Answer4\": \"5\",\n        \"Answer5\": \"33\",\n        \"Answer6\": \"32\",\n        \"Answer\": \"a\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele variante reprezintă modalități de comunicare între funcții?\",\n        \"Answer1\": \"apel\",\n        \"Answer2\": \"prin variabile locale\",\n        \"Answer3\": \"prin argumentele actuale\",\n        \"Answer4\": \"prin valoarea returnată\",\n        \"Answer5\": \"prin variabile globale\",\n        \"Answer6\": \"prin includere\",\n        \"Answer\": \"c,d,e\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Ce este contextul de apel al unei funcții?\",\n        \"Answer1\": \"lista argumentelor formale\",\n        \"Answer2\": \"o zonă de memorie (de pe stivă)\",\n        \"Answer3\": \"locul din textul sursă în care se apelează\",\n        \"Answer4\": \"instrucțiunile (definiția funcției)\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Care este valoarea variabilei n după execuția secvenței: char t[ ]=\\\"timisoara\\\", *p,*q,n; p=q=t; while(*(q++)); n=q-p;\",\n        \"Answer1\": \"n=0\",\n        \"Answer2\": \"n=9\",\n        \"Answer3\": \"n=10\",\n        \"Answer4\": \"n='\\\\0'-'t'\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Ce reprezintă declarația: int *(*f)(int *)? (i) funcţie ce primeşte argument pointer la întreg şi întoarce pointer la întreg ; \\n(ii) o declaraţie greşită; \\n(iii) pointer către o funcţie care aşteaptă ca argument un pointer la int şi întoarce un pointer la int; \\n(iv) pointer către o funcţie care întoarce un int\",\n        \"Answer1\": \"i\",\n        \"Answer2\": \"ii\",\n        \"Answer3\": \"iii\",\n        \"Answer4\": \"iv\",\n        \"Answer5\": \"nici una\",\n        \"Answer6\": \"toate\",\n        \"Answer7\": \"i şi iv\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Ce se afișează în urma executării următoarei secvențe de cod? #include <stdio.h>\\nvoid main() { char *u[2]={\\\"abc\\\",\\\"def\\\"}, **v; v=&u[0]; printf(\\\"%c\\\",(*v)[1]); }\",\n        \"Answer1\": \"a\",\n        \"Answer2\": \"b\",\n        \"Answer3\": \"c\",\n        \"Answer4\": \"d\",\n        \"Answer5\": \"e\",\n        \"Answer6\": \"f\",\n        \"Answer7\": \"abc\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbajul C\"\n    },\n    {\n        \"QuestionTitle\": \"Un constructor se caracterizează prin următoarele proprietăţi în limbajele C++/Java:\",\n        \"Answer1\": \"Este o funcţie membră care are acelaşi nume ca şi clasa în care este declarată\",\n        \"Answer2\": \"Este o funcţie membră care întoarce o valoare\",\n        \"Answer3\": \"Este o funcţie membră care nu are valoare de return\",\n        \"Answer4\": \"Este o funcţie membră utilizată pentru a iniţializa un obiect\",\n        \"Answer5\": \"Este o funcţie membră utilizată pentru a dealoca spaţiu de memorie\",\n        \"Answer6\": \"O clasă nu poate avea mai mult de un constructor\",\n        \"Answer\": \"a,c,d\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre următoarele afirmaţii sunt adevărate despre template-uri(C++)/generice(Java)?\",\n        \"Answer1\": \"Template-urile / genericele sunt o facilitate a limbajului care permit folosirea aceluiaşi cod pentru diferite tipuri de date\",\n        \"Answer2\": \"Template-urile / genericele sunt exemple de polimorfism.\",\n        \"Answer3\": \"Template-urile / genericele nu pot fi folosite cu tipuri de date abstracte definite de utilizator.\",\n        \"Answer4\": \"În afară de template-urile / genericele implicite nu pot fi definite altele noi.\",\n        \"Answer\": \"a,b\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre următoarele afirmaţii sunt adevărate în limbajele C++/Java?\",\n        \"Answer1\": \"O funcţie statică nu poate arunca o excepţie.\",\n        \"Answer2\": \"O funcţie statică nu poate accesa o variabilă membru non-statică a clasei.\",\n        \"Answer3\": \"O funcţie statică nu poate accesa o variabilă membru statică a clasei.\",\n        \"Answer4\": \"O variabilă membru statică a clasei nu poate fi modificată într-o funcţie membră non-statică.\",\n        \"Answer\": \"b\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Excepţiile sunt:\",\n        \"Answer1\": \"Erori care apar la compilarea programului\",\n        \"Answer2\": \"Situaţii speciale tratate în program prin teste de tipul if(variabila == NULL)\",\n        \"Answer3\": \"Erori care apar la rularea programului\",\n        \"Answer4\": \"'Aruncate' folosind instrucţiunea try şi 'tratate' folosind instrucţiunea catch\",\n        \"Answer5\": \"'Aruncate' folosind instrucţiunea throw(s) şi 'tratate' în blocuri try - catch (finally)\",\n        \"Answer\": \"c,e\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Care este asocierea corectă între următoarele verbe şi relaţiile între clase?\",\n        \"Answer1\": \"(1, a), (2, b), (3, c)\",\n        \"Answer2\": \"(1, b), (2, c), (3, a)\",\n        \"Answer3\": \"(1, c), (2, b), (3, a)\",\n        \"Answer4\": \"(1, b), (2, a), (3, c)\",\n        \"Answer\": \"b\",\n        \"Image\": \"cpp_5.png\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Principiul OCP (Open Close Principle) din cadrul principiilor SOLID se referă la:\",\n        \"Answer1\": \"Responsabilităţile pe care trebuie să le implementeze o clasă\",\n        \"Answer2\": \"Realizarea de ierarhii de clase consistente\",\n        \"Answer3\": \"Problemele care apar din cauza codului duplicat\",\n        \"Answer4\": \"Posibilitatea extinderii claselor şi evitarea modificărilor claselor şi codului existent\",\n        \"Answer\": \"d\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele afirmaţii sunt false în contextul supraîncărcării operatorilor în limbajul C++:\",\n        \"Answer1\": \"Se pot adăuga noi operatori limbajului\",\n        \"Answer2\": \"Se poate schimba n-aritatea (numărul de operanzi ai operatorului)\",\n        \"Answer3\": \"Nu toţi operatorii pot fi supraîncărcaţi\",\n        \"Answer4\": \"Operatorii se pot supraîncărca prin intermediul funcţiilor membre clasei şi funcţii prietene clasei.\",\n        \"Answer\": \"a,b\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"În limbajul C++, dacă o clasă X are ca membri variabile pointer, este recomandat să conţină:\",\n        \"Answer1\": \"Un destructor care nu face nimic X(){}\",\n        \"Answer2\": \"O funcţie friend care să permită copierea obiectului\",\n        \"Answer3\": \"Supraîncărcarea operatorului =\",\n        \"Answer4\": \"Constructorul de copiere\",\n        \"Answer5\": \"Supraîncărcarea operatorului ==\",\n        \"Answer6\": \"Un destructor în care se dealocă memoria adresată de membrii de tip pointer ai clasei\",\n        \"Answer\": \"c,d,f\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Se dă următoarea secventă de cod: De câte ori sunt apelați constructorii clasei Date?\",\n        \"Answer1\": \"2\",\n        \"Answer2\": \"3\",\n        \"Answer3\": \"4\",\n        \"Answer4\": \"5\",\n        \"Answer\": \"c\",\n        \"Image\": \"cpp_9.png\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"10. Care din următoarele afirmatii sunt adevărate?\",\n        \"Answer1\": \"clasa Curve nu poate fi instantiată deoarece metoda addControlPoint() nu este implementată\",\n        \"Answer2\": \"clasa Curve nu poate fi instantiată deoarece este clasă abstractă\",\n        \"Answer3\": \"codul se compilează cu succes\",\n        \"Answer\": \"b\",\n        \"Image\": \"cpp_10.png\",\n        \"Category\": \"Limbajul C++\"\n    },\n    {\n        \"QuestionTitle\": \"Dacă o metodă are ca parametru o referinţă la un obiect inmutabil, de exemplu clasa String, poate metoda să modifice starea obiectului?\",\n        \"Answer1\": \"Da, dacă avem o referinţă la un obiect imutabil îi putem modifica starea\",\n        \"Answer2\": \"Da, dar trebuie să folosim un operator special ''+'' ca să realizăm acest lucru\",\n        \"Answer3\": \"Nu, starea obiectelor imutabile nu poate fi modificată de nimeni după ce obiectul a fost creat\",\n        \"Answer4\": \"Nu, doar proprietarul obiectului imutabil poate să îi schimbe starea.\",\n        \"Answer\": \"c\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre afirmaţiile de mai jos este adevărată în relaţie cu limbajul Java?\",\n        \"Answer1\": \"Specificatorul final se aplică la clase, atribute si metode;\",\n        \"Answer2\": \"O metodă declarată final poate apela doar metode declarate final în aceeaşi clasă;\",\n        \"Answer3\": \"O metodă declarată final nu poate fi suprascrisă la subclasare;\",\n        \"Answer4\": \"Un atribut declarat final poate fi setat doar o singură dată;\",\n        \"Answer\": \"a,c,d\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre afirmaţiile de mai jos este/sunt adevărată/e despre conceptul de moştenire între clase?\",\n        \"Answer1\": \"Mecanismul prin care o clasă preia structura (datele membru) şi comportamentul (metodele) unei alte clase la care adaugă elemente specifice;\",\n        \"Answer2\": \"Prin mecanismul de moştenire avem acces la datele private ale clasei(claselor) de bază;\",\n        \"Answer3\": \"Nu toate limbajele de programare implementează conceptul de moştenire multiplă;\",\n        \"Answer4\": \"O metodă definită în clasa de bază nu poate fi suprascrisă în clasa derivată;\",\n        \"Answer5\": \"Moştenirea poate fi întotdeauna înlocuită cu compunerea obiectelor.\",\n        \"Answer\": \"a,c\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre afirmaţiile de mai jos este/sunt adevărată/e referitor la conceptul de clasă abstractă în limbajul Java:\",\n        \"Answer1\": \"O clasă care nu poate fi instanţiată;\",\n        \"Answer2\": \"Nu există nicio diferenţă între clasele abstracte şi interfeţe;\",\n        \"Answer3\": \"O clasă abstractă poate conţine variabile membre care nu sunt constante.\",\n        \"Answer\": \"a,c\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Care dintre afirmaţiile de mai jos este/sunt adevărată/e despre clase şi obiecte:\",\n        \"Answer1\": \"O clasă modelează caracteristici comune mai multor obiecte;\",\n        \"Answer2\": \"Un obiect este o realizare/instantă a unei clase;\",\n        \"Answer3\": \"O clasă este o realizare/instantă a unui obiect;\",\n        \"Answer4\": \"Nu există nicio legătură între clase şi obiecte.\",\n        \"Answer\": \"a,b\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele afirmaţii sunt false relativ la limbajul Java:\",\n        \"Answer1\": \"Orice clasă este derivată din clasa Object\",\n        \"Answer2\": \"O clasă poate extinde una sau mai multe clase de bază\",\n        \"Answer3\": \"O clasă poate implementa una sau mai multe interfeţe\",\n        \"Answer4\": \"Subclasele moştenesc atributele, metodele şi constructorii clasei de bază\",\n        \"Answer\": \"b,d\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Care din următoarele afirmat, ii este/sunt adevărare despre clasa PreparedStatement?\",\n        \"Answer1\": \"Interogarea este compilată de fiecare dată când este executată\",\n        \"Answer2\": \"Permite rularea aceleiași interogări, prin compilarea ei o singură dată  si parametrizarea cu valori diferite\",\n        \"Answer3\": \"Folosirea clasei PraparedStatement evită întotdeauna SQL Injection\",\n        \"Answer4\": \"SQL Injection poate fi evitat prin folosirea placeholderului '?'\",\n        \"Answer\": \"b,d\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Două funcţii care au același nume într-o clasă Java, pot fi diferenţiate datorită:\",\n        \"Answer1\": \"Numărului de variabile din lista de parametri\",\n        \"Answer2\": \"Nu pot fi diferenţiate\",\n        \"Answer3\": \"Tipului variabilelor din lista de variabile\",\n        \"Answer4\": \"Tipului de return al funcției\",\n        \"Answer\": \"a,c\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră următoarea secventă de cod: (vezi imagine) Care din variantele de mai jos instantiază şi lansează în executie un fir de execuţie?\",\n        \"Answer1\": \"new Thread()).start()\",\n        \"Answer2\": \"a.start( )\",\n        \"Answer3\": \"a.run( )\",\n        \"Answer4\": \"new Thread.run( )\",\n        \"Answer\": \"b\",\n        \"Image\": \"java_9.png\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Considerând următoarea secventă de cod, stabiliţi care este ordinea execuției (in ipoteza că o clasă are un constructor, o metodă, un bloc static si un bloc de instantă):\",\n        \"Answer1\": \"instance block; method; static block; constructor;\",\n        \"Answer2\": \"static block; instance block; constructor; method;\",\n        \"Answer3\": \"method; constructor; instance block; static block;\",\n        \"Answer4\": \"static block; method; instance block; constructor;\",\n        \"Answer5\": \"constructor; static block; instance block; method;\",\n        \"Answer\": \"b\",\n        \"Image\": \"java_10.png\",\n        \"Category\": \"Limbajul Java\"\n    },\n    {\n        \"QuestionTitle\": \"Se consideră următoarea secventă de cod: (vezi imagine) Care din variantele de mai jos se va afișa:\",\n        \"Answer1\": \"[mere,pere,banane,kiwi,ananas,portocale]\",\n        \"Answer2\": \"[ananas,banane,kiwi,mere,pere,portocale]\",\n        \"Answer3\": \"[Ljava.lang.String;@15db9742]\",\n        \"Answer4\": \"[portocale,ananas,kiwi,mere,banane,pere]\",\n        \"Answer\": \"b\",\n        \"Image\": \"java_11.png\",\n        \"Category\": \"Limbajul Java\"\n    },\n   {\n\"QuestionTitle\": \"Verificarea software-lui poate implica\",\n\"Answer1\": \"analiza statică automată\",\n\"Answer2\": \"evaluarea utilității și utilizabilității software-lui în situații operaționale.\",\n\"Answer3\": \"depanarea erorilor\",\n\"Answer4\": \"inspectări ale software-lui\",\n\"Answer5\": \"testarea în vederea descoperirii existenței erorilor\",\n\"Answer6\": \"testarea faptului că software-ul îndeplinește cerint,ele utilizator\",\n\"Answer\": \"a,d,e\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Diagrama de stări și tranziții reprezintă\",\n\"Answer1\": \"funcțiile sistemului\",\n\"Answer2\": \"răspunsul sistemului la evenimente interne\",\n\"Answer3\": \"răspunsul sistemului la evenimente externe\",\n\"Answer4\": \"interacțiuni între obiecte din sistem\",\n\"Answer5\": \"structura datelor\",\n\"Answer6\": \"interact,iunile actorilor cu sistemul\",\n\"Answer7\": \"fluxul de prelucrare a datelor în sistem\",\n\"Answer\": \"b,c\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Metodele agile de dezvoltare de software implică\",\n\"Answer1\": \"Furnizare incrementală\",\n\"Answer2\": \"Implicarea clientului pe parcursul procesului de dezvoltare\",\n\"Answer3\": \"Instituirea de procese normative pentru lucrul în echipă\",\n\"Answer4\": \"Acțiuni periodice de eliminare a complexității din sistem\",\n\"Answer5\": \"Modelarea completă a software-lui înainte de scrierea codului\",\n\"Answer\": \"a,b,d\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Bifați situațiile în care se reutilizează doar concepte:\",\n\"Answer1\": \"Servicii software\",\n\"Answer2\": \"Șabloane de proiectare (design patterns)\",\n\"Answer3\": \"Biblioteci de programe\",\n\"Answer4\": \"Șabloane arhitecturale\",\n\"Answer\": \"b,d\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n        \"QuestionTitle\": \"Fie următoarea diagramă de clase.Fie următoarea diagramă de clase.\",\n        \"Answer1\": \"Un obiect de tip ComputerScience conține o colecție de obiecte de tip Student\",\n        \"Answer2\": \"Clasa Questionnaire are un atribut public de tip String\",\n        \"Answer3\": \"Clasa ComputerScience are operația publică addStudent(s:String)\",\n        \"Answer4\": \"Clasa ComputerScience are operația privată setSchedule(s:String)\",\n        \"Answer5\": \"Clasa Tutor este superclasă pentru clasa Masterand\",\n\t\t\"Answer6\": \"Clasa ComputerScience definește o compoziție de obiecte de tip Questionnaire.\",\n\t\t\"Answer7\": \"Între clasa ComputerScience și clasa Tutor există o asociere unidirecțională.\",\n\t\t\"Answer8\": \"Clasa ComputerScience moștenește interfața Specialization.\",\n\t\t\"Answer9\": \"Clasa Tutor definește un agregat de obiecte de tip Masterand.\",\n        \"Answer\": \"a,c,e,f\",\n\t\t\"Image\":\"pas_5.png\",\n        \"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de clase. Care secvență de cod Java descrie corect și complet relațiile clasei Proiect?\",\n\"Answer1\": \"class Proiect extends Student {\\nprivate Collection <DiagramaUML> diagramele = new ArrayList<>();\\nprivate CodSursa codul;\\n...},\",\n\"Answer2\": \"class Proiect {\\nprivate Collection <Student> studenti;\\nprivate Collection <DiagramaUML> diagramele = new ArrayList<>();\\nprivate CodSursa codul;\\n...},\",\n\"Answer3\": \"class Proiect {\\nprivate Student student;\\nprivate DiagramaUML diagrama;\\nprivate CodSursa codul;\\n...},\",\n\"Answer4\": \"class Proiect {\\nprivate Collection <Student> studenti = new ArrayList<>();\\nprivate Collection <DiagramaUML> diagramele;\\nprivate CodSursa codul;\\n...},\",\n\"Answer\": \"b\",\n\"Image\":\"pas_6.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de clase. Care secvență de cod Java descrie corect și complet relațiile clasei Revista?\",\n\"Answer1\": \"class Revista extends RevistaOnLine implements Produs {\\nprivate Collection <Articol> articole;\\n...},\",\n\"Answer2\": \"class Revista implements Produs {\\nprivate Collection <Articol> articole = new LinkedList<>();\\nprivate RevistaOnLine revista;\\n...},\",\n\"Answer3\": \"class Revista implements Produs {\\nprivate Collection <Articol> articole = new LinkedList<>();\\n...},\",\n\"Answer4\": \"class Revista extends RevistaOnLine {\\nprivate Collection <Articol> articole = new LinkedList<>();\\nprivate Produs produs;\\n...},\",\n\"Answer\": \"c\",\n\"Image\":\"pas_7.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de clase. Selectați descrierea corectă și completă a relațiilor reprezentate în diagramă:\",\n\"Answer1\": \"Asociere bidirecțională între clasele Proiect și CodSursa; compoziție între clasele Proiect (componentă) și DiagramaUML (componenta); agregare între clasele Proiect (agregat) și Student (componenta); generalizare între interfața IStudent (implementată) și clasa Student (implementează); realizare între clasa Student (superclasă) și clasa Bursier (subclasă)\",\n\"Answer2\": \"Asociere bidirecțională între clasele Proiect și CodSursa; compoziție între clasele Proiect (componentă) și DiagramaUML (componenta); agregare între clasele Proiect (agregat) și Student (componenta); realizare între interfața IStudent (implementată) și clasa Student (implementează); generalizare între clasa Student (superclasă) și clasa Bursier (subclasă)\",\n\"Answer3\": \"Asociere bidirecțională între clasele Proiect și CodSursa; agregare între clasele Proiect (agregat) și DiagramaUML (componenta); compoziție între clasele Proiect (agregat) și Student (componenta); realizare între interfața IStudent (implementată) și clasa Student (implementează); generalizare între clasa Student (superclasă) și clasa Bursier (subclasă)\",\n\"Answer4\": \"Asociere bidirecțională între clasele Proiect și CodSursa; compoziție între clasele DiagramaUML (componenta) și Proiect (componenta); agregare între clasele Student (agregat) și Proiect (componenta); realizare între interfața IStudent (implementată) și clasa Student (implementează); generalizare între clasa Student (superclasă) și clasa Bursier (subclasă)\",\n\"Answer\": \"b\",\n\"Image\":\"pas_8.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de clase. Care secvență de cod Java descrie corect și complet relația clasei Proiect cu clasa Student?\",\n\"Answer1\": \"class Student extends Proiect{...},\\nclass Proiect{...},\",\n\"Answer2\": \"class Proiect extends Student{...},\\nclass Student{...},\",\n\"Answer3\": \"class Proiect {\\n private Collection <Student> studenti ...\\n},\\nclass Student{...},\",\n\"Answer4\": \"class Proiect {\\n private Collection <Student> studenti ...\\n},\\nclass Student {\\n private Proiect proiect;\\n ...},\",\n\"Answer5\": \"class Proiect {\\n private Collection <Student> studenti ...\\n},\\nclass Student {\\n private Collection<Proiect> proiecte;\\n ...},\",\n\"Answer\": \"c\",\n\"Image\":\"pas_9.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de secvențe. Ce operații ale clasei ControlerInscriere rezultă din aceasta?\",\n\"Answer1\": \"getCursuri()\",\n\"Answer2\": \"display(listaCursuriOferite)\",\n\"Answer3\": \"inscriere(student, listaCursuriSelectate)\",\n\"Answer4\": \"Plan(listaCursuriSelectate)\",\n\"Answer5\": \"addPlan(planCurent)\",\n\"Answer6\": \"displayMsg('OK')\",\n\"Answer\": \"a,c\",\n\"Image\":\"pas_10.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de secvențe. Selectați clasele din care sunt instanțiate obiectele implicate în interacțiune:\",\n\"Answer1\": \"InscriereForm\",\n\"Answer2\": \"ControlerInscriere\",\n\"Answer3\": \"listaCursuriSelectate\",\n\"Answer4\": \"curent\",\n\"Answer5\": \"Student\",\n\"Answer6\": \"Plan\",\n\"Answer7\": \"planCurent\",\n\"Answer\": \"a,b,e,f\",\n\"Image\":\"pas_11.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Fie următoarea diagramă de robustețe. Care afirmatii sunt adevărate?\",\n\"Answer1\": \"Home page este obiect boundary.\",\n\"Answer2\": \"ExtrageListaCarti poate fi obiect persistent.\",\n\"Answer3\": \"AfiseazaLinkuri este obiect de interacțiune cu actor.\",\n\"Answer4\": \"ExtrageListaCarti ar putea fi implementat ca metodă a unei clase entity.\",\n\"Answer5\": \"ListaCarti este obiect de interacțiune cu actor.\",\n\"Answer6\": \"Catalog este obiect entity.\",\n\"Answer\": \"a,d,f\",\n\"Image\":\"pas_12.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Selectați perechea de termeni cu care se înlocuiesc spațiile libere din următoarea frază:\",\n\"Answer1\": \"criterii / activități\",\n\"Answer2\": \"componente / roluri\",\n\"Answer3\": \"alphas / activity spaces\",\n\"Answer4\": \"criterii / alpha states\",\n\"Answer5\": \"alpha states / criterii\",\n\"Answer\": \"d\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Realizați corespondența corectă între concept și definiția sa:\",\n\"Answer1\": \"a – 5, b – 1, c – 4, d – 3, e – 2.\",\n\"Answer2\": \"a – 5, b – 3, c – 4, d – 1, e – 2\",\n\"Answer3\": \"a – 2, b – 1, c – 3, d – 4, e – 5\",\n\"Answer4\": \"a – 1, b – 2, c – 3, d – 4, e – 5\",\n\"Answer5\": \"a – 3, b – 2, c – 4, d – 5, e – 1\",\n\"Answer\": \"a\",\n\"Image\":\"pas_14.png\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n{\n\"QuestionTitle\": \"Selectați metodele de evitare a introducerii de erori în dezvoltarea de programe:\",\n\"Answer1\": \"Fiecare clasă trebuie să aibă o singură responsabilitate\",\n\"Answer2\": \"Folosire expresii regulate pentru validarea datelor de intrare\",\n\"Answer3\": \"Evitarea încuibării multiple de instrucțiuni condiționale\",\n\"Answer4\": \"Jurnalizarea interacțiunii utilizatorilor cu programul\",\n\"Answer5\": \"Înlocuirea corpului unei metode cu un nou algoritm mai clar care returnează același rezultat\",\n\"Answer6\": \"Minimizarea adâncimii ierarhiilor de clase\",\n\"Answer7\": \"Salvare automată a datelor utilizatorului la intervale presetate\",\n\"Answer8\": \"Identificarea aspectelor care variază ale unei aplicații și separarea lor de cele care nu variază\",\n\"Answer9\": \"Verificare valori date de intrare față de domeniul definit cu reguli de intrare\",\n\"Answer10\": \"Folosire aserțiuni pentru verificare rezultat de la un serviciu extern\",\n\"Answer\": \"a,c,e,f,h\",\n\"Category\": \"Proiectarea aplicațiilor software\"\n},\n\t    {\n      \"QuestionTitle\": \"Care din următoarele sunt proprietăţi ale cheii candidate?\",\n      \"Answer1\": \"Unicitatea\",\n      \"Answer2\": \"Ireductibilitatea\",\n      \"Answer3\": \"Segregarea domeniului de valori\",\n      \"Answer4\": \"Completitudinea\",\n      \"Answer\": \"a,b\",\n      \"Category\": \"Baze de date\"\n    },\n    {\n      \"QuestionTitle\": \"Care din următoarele sunt limbaje ale bazei de date?\",\n      \"Answer1\": \"Data Definition Language (DDL)\",\n      \"Answer2\": \"Database Distribution Language (DDL)\",\n      \"Answer3\": \"Data Manipulation Language (DML)\",\n      \"Answer4\": \"Data Maintenance Language (DML)\",\n      \"Answer5\": \"Data Query Language (DQL)\",\n      \"Answer6\": \"Data Analysis Language (DAL)\",\n      \"Answer\": \"a,c,e\",\n      \"Category\": \"Baze de date\"\n    },\n    {\n      \"QuestionTitle\": \"Se consideră tabela R(A) conţinând înregistrările {(1), (2)} şi tranzacţiile \\n(T1) UPDATE R SET A = A*2 \\n(T2) SELECT AVG(A) FROM R; SELECT MAX(A) FROM R \\nDacă tranzacţia T2 se execută folosind nivelul de izolare repeatable read, care dintre următoarele afirmaţii este adevărată\",\n      \"Answer1\": \"Dacă AVG(A) = 1.5 atunci MAX(A) poate să ia valorile 2 sau 4\",\n      \"Answer2\": \"AVG(A) va fi întotdeauna 1.5 iar MAX(A) = 2\",\n      \"Answer3\": \"AVG(A) poate să ia valorile 1.5 sau 3, iar MAX(A) valorile 2 sau 4\",\n      \"Answer4\": \"Dacă MAX(A) = 4 atunci AVG(A) este 1.5\",\n      \"Answer\": \"c\",\n      \"Category\": \"Baze de date\"\n    },\n    {\n      \"QuestionTitle\": \"Care dintre următoarele aspecte sunt adresate de normalizare?\",\n      \"Answer1\": \"Anomaliile la ştergere\",\n      \"Answer2\": \"Anomaliile la inserare\",\n      \"Answer3\": \"Anomaliile la actualizare\",\n      \"Answer4\": \"Redundanţa datelor\",\n      \"Answer5\": \"Volumul datelor\",\n      \"Answer\": \"a,b,c,d\",\n      \"Category\": \"Baze de date\"\n    },\n\t{\n      \"QuestionTitle\": \"Trei dintre expresiile relaţionale de mai jos returnează numele studenţilor care nu au aplicat la specializările CS sau PH. Care returnează altceva? (Observaţie: numele studenţilor pot fi duplicate.)\",\n       \"Answer1\": \"bd_5_a.png\",\n        \"Answer2\": \"bd_5_b.png\",\n        \"Answer3\": \"bd_5_c.png\",\n        \"Answer4\": \"bd_5_d.png\",\n\t  \"Answer\": \"d\",\n      \"Category\": \"Baze de date\"\n    },\n\t  {\n      \"QuestionTitle\": \"Consideraţi următoarea interogare SQL. Care dintre indecşii următori sunt cei mai potriviţi pentru accelearea execuţiei interogării de mai sus?\",\n      \"Answer1\": \"Student.sID şi Student.Bac\",\n      \"Answer2\": \"Apply.cName şi College.cName\",\n      \"Answer3\": \"Apply.sID şi College.cName\",\n      \"Answer4\": \"Apply.sID şi Student.Bac\",\n      \"Answer\": \"c\",\n\t  \"Image\":\"bd_6.png\",\n      \"Category\": \"Baze de date\"\n    },\n\t    {\n      \"QuestionTitle\": \"Ce returnează următoarea interogare SQL?\",\n      \"Answer1\": \"numele salariaţilor care ar trece la următorul nivel de salarizare după o creştere de 25% a salariului.\",\n      \"Answer2\": \"numele managerilor care ar trece la următorul nivel de salarizare după o creştere de 25% a salariului.\",\n      \"Answer3\": \"angajaţii care ar trece la următorul nivel de salarizare după o creştere a salariului de 25%, dacă salariul lor se situează între salariul minim şi cel maxim.\",\n      \"Answer4\": \"Niciuna dintre cele enumerate mai sus.\",\n      \"Answer\": \"b\",\n\t  \"Image\":\"bd_7.png\",\n      \"Category\": \"Baze de date\"\n    },\n\t\t    {\n      \"QuestionTitle\": \"Tabelul de mai jos conţine un eşantion de date reprezentativ pentru toate dependenţele funcţionale dintr-un set de date real. Care sunt dependenţe funcţionale ce pot fi extrase din aceste date?\",\n      \"Answer1\": \"A → {B, C}, E → {F}\",\n      \"Answer2\": \"D → {A, B, C, E, F}, F → {E}\",\n      \"Answer3\": \"{A, E} → {D}\",\n      \"Answer4\": \"{D, E} → {A, B}\",\n      \"Answer\": \"a,c\",\n\t  \"Image\":\"bd_8.png\",\n      \"Category\": \"Baze de date\"\n    },\n\t{\n  \"QuestionTitle\": \"Considerând relaţia R(A, B, C, D, E, F) unde A - F sunt coloanele din tabelul de mai sus şi dependenţele funcţionale tot cele de mai sus, care dintre următoarele seturi de atribute este cheie candidată?\",\n  \"Answer1\": \"{B, F}\",\n  \"Answer2\": \"{A, E}\",\n  \"Answer3\": \"{A, E, D}\",\n  \"Answer4\": \"{A}\",\n  \"Answer\": \"b\",\n  \"Category\": \"Baze de date\"\n},\n  {\n  \"QuestionTitle\": \"Relativ la relaţia R de mai sus, care dintre următoarele afirmaţii sunt false?\",\n  \"Answer1\": \"Relaţia se află în prima formă normală\",\n  \"Answer2\": \"Relaţia se află în a doua formă normală\",\n  \"Answer3\": \"La o adresă (coloana B) nu pot corespunde valori diferite în coloana A\",\n  \"Answer4\": \"Nu pot exista două înregistrări în tabela R cu valori diferite în coloana D dacă valorile din coloana A sunt identice\",\n  \"Answer\": \"b,c,d\",\n  \"Category\": \"Baze de date\"\n  },\n{\n  \"QuestionTitle\": \"Fie relața R(A,B,C,D,E) în care se verifică următoarele dependențe funcționale D → C, {C,E} → A, D → A, {B,E} → D. Care dintre următoarele seturi de atribute este cheie a relației?\",\n  \"Answer1\": \"{B, E}\",\n  \"Answer2\": \"{C, D}\",\n  \"Answer3\": \"{A, C}\",\n  \"Answer4\": \"{A, C, E}\",\n  \"Answer\": \"a\",\n  \"Category\": \"Baze de date\"\n},\n{\n  \"QuestionTitle\": \"Fie următoarea diagramă E/R. Care dintre următoarele relat,ii fac parte din reprezentarea acestei diagrame în modelul relaţional?\",\n  \"Answer1\": \"Courses(CID, title)\",\n  \"Answer2\": \"Students(SID, name)\",\n  \"Answer3\": \"Enroll(SID,CID)\",\n  \"Answer4\": \"Enroll(SID, name, CID, title, grade)\",\n  \"Answer5\": \"Students(SID, name, CID)\",\n  \"Answer6\": \"Enroll(SID, CID, grade)\",\n  \"Answer\": \"a,b,f\",\n  \"Image\":\"bd_12.png\",\n  \"Category\": \"Baze de date\"\n},\n{\n  \"QuestionTitle\": \"Se dau tabelele R(A,B), S(B,C) care conţin următoarele înregistrări R=(1,2), (2,2), (5,1), iar S=(2, 2), (2, 1). Fie vederea V definită prin următoarea interogare \\nSELECT A, C FROM R JOIN S ON R.B = S.B \\n Care dintre următoarele înregistrări fac parte din vederea V?\",\n  \"Answer1\": \"(1,1)\",\n  \"Answer2\": \"(1,2)\",\n  \"Answer3\": \"(2,1)\",\n  \"Answer4\": \"(2,2)\",\n  \"Answer5\": \"(5,1)\",\n  \"Answer6\": \"(5,2)\",\n  \"Answer7\": \"(1,5)\",\n  \"Answer8\": \"(2,5)\",\n  \"Answer\": \"a,b,c,d\",\n  \"Category\": \"Baze de date\"\n},\n{\n  \"QuestionTitle\": \"Care dintre următoarele instrucţiuni poate fi folosită ca instrucţiune următoare în secvenţa de cod de mai jos?\",\n  \"Answer1\": \"END TRANSACTION\",\n  \"Answer2\": \"END\",\n  \"Answer3\": \"COMMIT\",\n  \"Answer4\": \"ROLLBACK TRANSACTION\",\n  \"Answer\": \"c,d\",\n  \"Image\":\"bd_14.png\",\n  \"Category\": \"Baze de date\"\n},\n\t{\n  \"QuestionTitle\": \"Registrul Program Contor conține:\",\n  \"Answer1\": \"adresa următoarei instrucțiuni din memorie\",\n  \"Answer2\": \"adresa datelor extrase din memorie\",\n  \"Answer3\": \"rezultatul operațiilor aritmetice efectuate\",\n  \"Answer4\": \"adresa de unde va fi extrasă instrucțiunea ce urmează a fi executată\",\n  \"Answer\": \"d\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Timpul mediu necesar pentru a accesa o locație de memorie și a prelua conținutul acesteia poartă numele de:\",\n  \"Answer1\": \"timp de latență\",\n  \"Answer2\": \"timp de căutare\",\n  \"Answer3\": \"timp de acces\",\n  \"Answer4\": \"timp de răspuns\",\n  \"Answer\": \"c\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Tipul de memorie folosit pentru a crește viteza de procesare a unui calculator este:\",\n  \"Answer1\": \"RAM\",\n  \"Answer2\": \"Cache\",\n  \"Answer3\": \"BIOS\",\n  \"Answer4\": \"ROM\",\n  \"Answer\": \"b\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Suma dintre -6 și -13, folosind reprezentarea în complement față de 2, este:\",\n  \"Answer1\": \"11101101\",\n  \"Answer2\": \"11100001\",\n  \"Answer3\": \"01010101\",\n  \"Answer4\": \"10101011\",\n  \"Answer\": \"a\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Care este valoarea stocată la adresa c după executarea următoarei secvențe de cod?\",\n  \"Answer1\": \"ac_5_a.png\",\n  \"Answer2\": \"ac_5_b.png\",\n  \"Answer3\": \"ac_5_c.png\",\n  \"Answer4\": \"ac_5_d.png\",\n  \"Answer\": \"a,d\",\n  \"Image\":\"ac_5.png\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Ce tehnică ajută procesorul să ruleze un program concomitent cu operațiile de intrare/ieșire?\",\n  \"Answer1\": \"DMA\",\n  \"Answer2\": \"transfer prin program\",\n  \"Answer3\": \"niciunul dintre răspunsuri\",\n  \"Answer4\": \"transfer prin întreruperi\",\n  \"Answer\": \"d\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Care este cea mai mare unitate de transfer a datelor din memoria unui sistem de calcul?\",\n  \"Answer1\": \"cuvânt\",\n  \"Answer2\": \"bloc\",\n  \"Answer3\": \"bit\",\n  \"Answer4\": \"niciuna dintre acestea\",\n  \"Answer\": \"b\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Pentru un număr dat/fix de biți, numărul de valori distincte care pot fi reprezentate este:\",\n  \"Answer1\": \"mai mare pentru întregi fără semn\",\n  \"Answer2\": \"mai mare pentru întregi cu semn\",\n  \"Answer3\": \"același pentru întregi cu semn și întregi fără semn\",\n  \"Answer\": \"c\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Diferența între procesoarele CISC și RISC constă în:\",\n  \"Answer1\": \"procesoarele CISC au un număr mai mare de instrucțiuni\",\n  \"Answer2\": \"procesoarele RISC prezintă riscuri mai mari în utilizare\",\n  \"Answer3\": \"procesoarele RISC execută o instrucțiune într-un singur ciclu\",\n  \"Answer\": \"a,c\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"O întrerupere hardware reprezintă:\",\n  \"Answer1\": \"un semnal sincron/asincron la un periferic care semnalizează apariția unui eveniment care trebuie tratat de către procesor\",\n  \"Answer2\": \"întreruperea funcționării procesorului în urma unui bug software\",\n  \"Answer3\": \"întreruperea unui circuit de conectare între două sau mai multe componente hardware\",\n  \"Answer\": \"a\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Arhitectura Harvard are:\",\n  \"Answer1\": \"două magistrale, una pentru date și una pentru instrucțiuni\",\n  \"Answer2\": \"două memorii, una pentru date și una pentru instrucțiuni/program\",\n  \"Answer3\": \"drept dezavantaj major faptul că magistrala de date este mai ocupată decât magistrala de program\",\n  \"Answer\": \"a,b,c\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"La magistralele sincrone:\",\n  \"Answer1\": \"ciclurile de transfer sunt direct corelate cu semnalul de tact (CPU clock)\",\n  \"Answer2\": \"nu există o legatură directă între evoluția în timp a unui ciclu de transfer și semnalul de tact al ceasului procesorului\",\n  \"Answer3\": \"se face permanent o sincronizare a acestora cu magistralele asincrone\",\n  \"Answer\": \"a\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"O poartă logică este:\",\n  \"Answer1\": \"un program software capabil să efectueze o anumită operație (logică) asupra unor semnale electrice\",\n  \"Answer2\": \"un conector care permite preluarea valorilor logice de la utilizator\",\n  \"Answer3\": \"un dispozitiv hardware capabil să efectueze o anumită operație (logică) asupra unor semnale electrice\",\n  \"Answer\": \"c\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Circuitele de memorare SR-latch (S-Set, R-Reset):\",\n  \"Answer1\": \"Stochează o singură valoare binară\",\n  \"Answer2\": \"Ieșirile celor două porturi logice folosite pentru realizare sunt tot timpul complementare\",\n  \"Answer3\": \"Setează și resetează în mod continuu valorile numerice stocate\",\n  \"Answer\": \"a,b\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n  \"QuestionTitle\": \"Circuit combinational:\",\n  \"Answer1\": \"Este un circuit format din porți logice, care nu are memorie și al cărui output depinde doar de inputul prezent/curent, NU de inputul precedent sau de starea curentă în care se află circuitul\",\n  \"Answer2\": \"Este un circuit electric în care informațiile sunt combinate în mod aleator pentru a obține valori aleatoare\",\n  \"Answer3\": \"Este un circuit care transpus într-un graf nu conține cicluri\",\n  \"Answer\": \"a,c\",\n  \"Category\": \"Arhitectura calculatoarelor\"\n},\n{\n\"QuestionTitle\": \"Care dintre următoarele mecanisme pot fi folosite pentru o implementare corectă a problemei secțiunii critice fără utilizarea așteptării active?\",\n\"Answer1\": \"semafoare\",\n\"Answer2\": \"algoritmul lui Dekker\",\n\"Answer3\": \"algoritmul lui Peterson\",\n\"Answer4\": \"mecanismul TSL\",\n\"Answer5\": \"monitoare\",\n\"Answer\": \"a,e\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Se consideră 5 segmente de memorie (A,B,C,D,E) cu mărimile 2k, 6k, 4k, 3k, 4k şi o memorie totală de 16k. În memorie se încarcă în ordine segmentele A, B, C, D. Care dintre aceste segmente urmează să fie evacuat pentru a putea permite încărcarea ulterioară a segmentului E?\",\n\"Answer1\": \"A\",\n\"Answer2\": \"B\",\n\"Answer3\": \"C\",\n\"Answer4\": \"D\",\n\"Answer5\": \"niciunul\",\n\"Answer\": \"b,c,d\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Care dintre problemele clasice de comunicare între procese pune în evidenţă o situaţie de impas?\",\n\"Answer1\": \"Problema filosofilor la masă\",\n\"Answer2\": \"Problema cititorilor şi scriitorilor\",\n\"Answer3\": \"Problema producător-consumator\",\n\"Answer4\": \"Problema frizerului\",\n\"Answer5\": \"niciuna dintre aceste probleme\",\n\"Answer\": \"a\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Se consideră un set de 10 procese planificate conform algoritmului Round Robin. Se cunosc următoarele informaţii: cuanta utilizată este 8, numărul final de comutări de context este 25, valoarea raportului T1/T2 = 2.25, unde T1 şi T2 sunt timpii estimaţi de execuţie pentru cel mai lung si cel mai scurt proces, pentru care timpul estimat de execuţie depăşeşte valoarea cuantei (cu cel puțin 25%). Determinaţi cea mai mică valoare posibilă pentru perechea (T1, T2).\",\n\"Answer1\": \"27, 12\",\n\"Answer2\": \"31, 14\",\n\"Answer3\": \"34, 15\",\n\"Answer4\": \"36, 16\",\n\"Answer\": \"a\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Se consideră un set de 10 procese planificate conform algoritmuluii SJF, în care procesele sosesc în sistem la momentele T1 = 0, T2 = 13, T3 = 26. La fiecare moment sosesc cel puţin 3 procese, cu timpi estimaţi de execuţie diferiţi. Dacă pentru procesele P1, P5 şi P7 avem timpii de aşteptare 0, 0, 0 şi timpii de răspuns 14, 3, 6, identificaţi la ce moment a sosit procesul P1, apoi răspundeţi la următoarea întrebare: determinaţi timpii estimaţi de execuţie pentru cel puţin 6 procese, ştiind că nu există perioade de pauză ale procesorului şi că pot exista procese cu acelaşi timp estimat de execuţie, sosite la momente diferite?\",\n\"Answer1\": \"3, 4, 5, 6, 7, 8\",\n\"Answer2\": \"3, 4, 5, 6, 6, 8\",\n\"Answer3\": \"3, 4, 5, 6, 7, 14\",\n\"Answer4\": \"3, 4, 6, 6, 7, 14\",\n\"Answer\": \"d\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Într-un sistem pe 16 biţi cu 8 pagini virtuale şi 4 pagini cadru este folosit pentru paginare algoritmul FIFO. La un moment dat, în memorie sunt mapate paginile (2, 5, 7, 1). După acest moment vor fi accesate următoarele adrese: 12411, 16729, 2560, 9215, 20952. Care va fi maparea paginilor după ultima accesare, ştiind că următoarea pagină evacuată este prima pagină cadru?\",\n\"Answer1\": \"5, 2, 0, 4\",\n\"Answer2\": \"3, 4, 2, 5\",\n\"Answer3\": \"2, 5, 0, 3\",\n\"Answer4\": \"5, 4, 0, 2\",\n\"Answer\": \"d\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Într-un sistem pe 16 biţi cu 8 pagini virtuale şi 4 pagini cadru este folosit pentru paginare algoritmul Ceasului, fără îmbătrânire. La un moment dat, în memorie sunt mapate paginile (2, 5, 7, 1) iar următoarea pagină testată va fi prima pagină cadru. După încercările de acces către paginile, nu neapărat în această ordine, 1, 2, 3, 4, 5, 7 maparea devine (1, 5, 7, 2). Care dintre cele 4 pagini iniţiale au avut bitul R setat?\",\n\"Answer1\": \"toate\",\n\"Answer2\": \"niciuna\",\n\"Answer3\": \"paginile 5 si 7\",\n\"Answer4\": \"paginile 2, 5 si 7\",\n\"Answer\": \"c\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Se consideră situaţia a 3 fire de control a execuţiei care partajează variabilele A şi B. Accesul către cele două variabile este nerestricţionat, iar operaţiile realizate sunt, în fiecare fir de control a execuţiei, următoarele A = A+B,B = A−B,A = A−B. Precizaţi care dintre următoarele valori sunt posibile la sfârşitul execuţiei celor trei fire de control a execuţiei, atunci când A = 5,B = 7\",\n\"Answer1\": \"A = 5, B = 7\",\n\"Answer2\": \"A = 7, B = 5\",\n\"Answer3\": \"A = -29, B = 17\",\n\"Answer4\": \"A = -31, B = 19\",\n\"Answer\": \"b,d\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Se consideră o situaţie simplă cu 6 procese şi un singur tip de resurse. Starea sistemului este descrisă prin Are = (4, 2, 0, 5, 1, 4), Max = (8, 10, 10, 25, 25, 30), Disponibil = D. Determinaţi valoarea minimă D pentru care starea este sigură şi permite apoi alocarea a 3 resurse suplimentare către procesul al doilea.\",\n\"Answer1\": \"D = 12\",\n\"Answer2\": \"D = 14\",\n\"Answer3\": \"D = 13\",\n\"Answer4\": \"D = 11\",\n\"Answer\": \"b\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Se consideră o situaţie simplă cu 6 procese şi un singur tip de resurse. Starea sistemului este descrisă prin Are = (4, 2, 0, 5, 1, 4), Max = (14, 6, 8, 29, 27, 24), Disponibil = D. Determinaţi valoarea minimă D pentru care starea este sigură şi permite apoi alocarea a 3 resurse suplimentare către procesul al treilea.\",\n\"Answer1\": \"D = 11\",\n\"Answer2\": \"D = 13\",\n\"Answer3\": \"D = 14\",\n\"Answer4\": \"D = 12\",\n\"Answer\": \"c\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Care dintre următoarele reprezintă operaţii atomice permise asupra semafoarelor?\",\n\"Answer1\": \"wait\",\n\"Answer2\": \"up\",\n\"Answer3\": \"sleep\",\n\"Answer4\": \"down\",\n\"Answer\": \"b,d\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"O instrucţiune TSL ar trebui să fie executată?\",\n\"Answer1\": \"după fiecare proces în parte\",\n\"Answer2\": \"periodic\",\n\"Answer3\": \"într-o manieră atomică\",\n\"Answer4\": \"în niciuna dintre situaţiile precizate\",\n\"Answer\": \"c\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"O unitate de execuţie care nu poate fi întreruptă este\",\n\"Answer1\": \"simplă\",\n\"Answer2\": \"statică\",\n\"Answer3\": \"atomică\",\n\"Answer4\": \"dinamică\",\n\"Answer\": \"c\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Precizaţi principalele dezavantaje ale spinlock-urilor\",\n\"Answer1\": \"nu sunt eficiente pentru multe multe procese\",\n\"Answer2\": \"implică tehnici de aşteptare activă\",\n\"Answer3\": \"pot fi nesigure ocazional\",\n\"Answer4\": \"sunt prea complexe pentru programatori\",\n\"Answer\": \"b\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Fiecare dintre procesele Pi, cu i = 0, 1, . . . , 9 este caracterizat prin următoarea secvență de cod. Într-un al 11-lea proces, P10, liniile up(mutex) și down(mutex) au fost inversate. Care este numărul maxim de procese care s-ar putea găsi simultan în regiunea critică în acest caz, știind că inițial este permisă trecerea prin mutex?\",\n\"Answer1\": \"1\",\n\"Answer2\": \"2\",\n\"Answer3\": \"3\",\n\"Answer4\": \"Oricare dintre variantele a), b), c)\",\n\"Answer5\": \"Niciuna dintre variantele a), b), c)\",\n\"Answer\": \"d\",\n\"Image\": \"so_15.png\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Într-un sistem se găsesc trei procese concurente, în care se găsesc următoarele bucăți de cod, sincronizate prin trei semafoare binare. Semafoarele sunt init, ializate cu valorile S0 = 1, S1 = 0 și S2 = 0. De câte ori va executa primul proces linia print ‘0’ ?\",\n\"Answer1\": \"Cel put,in de două ori\",\n\"Answer2\": \"Exact de două ori\",\n\"Answer3\": \"Exact de trei ori\",\n\"Answer4\": \"Cel mult de trei ori\",\n\"Answer5\": \"Exact o dată\",\n\"Answer\": \"a\",\n\"Image\": \"so_16.png\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Modificarea unui semafor este posibilă în\",\n\"Answer1\": \"secțiunea critică\",\n\"Answer2\": \"zona aflată înaintea unei secțiuni critice\",\n\"Answer3\": \"zona situată după secțiunea critică\",\n\"Answer4\": \"oricare dintre aceste zone\",\n\"Answer5\": \"niciuna dintre aceste zone\",\n\"Answer\": \"a\",\n\"Category\": \"Sisteme de operare\"\n},\n{\n\"QuestionTitle\": \"Intr-un segment TCP ce câmp permite nodului receptor să determine dacă un segment TCP a fost deteriorat în timpul transmisiei?\",\n\"Answer1\": \"suma de control\",\n\"Answer2\": \"flags\",\n\"Answer3\": \"hash\",\n\"Answer4\": \"padding\",\n\"Answer\": \"a\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Care dintre următoarele dispozitive se află la nivelul 2 OSI?\",\n\"Answer1\": \"bridge(punte)\",\n\"Answer2\": \"repeater(repetor)\",\n\"Answer3\": \"router\",\n\"Answer4\": \"switch\",\n\"Answer5\": \"hub\",\n\"Answer\": \"a,d\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Pentru a asigura integritatea datelor, protocoalele orientate pe conexiune (ca TCP) folosesc:\",\n\"Answer1\": \"semnătura digitala\",\n\"Answer2\": \"certificate digitale\",\n\"Answer3\": \"algoritmi de criptare simetrici\",\n\"Answer4\": \"suma de control (checksum)\",\n\"Answer\": \"d\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Ordinea corectă a încapsulării mesajelor este:\",\n\"Answer1\": \"date, cadre, pachete, segmente, biți\",\n\"Answer2\": \"segmente, date, pachete, cadre, biți\",\n\"Answer3\": \"date, segmente, pachete, cadre, biți\",\n\"Answer4\": \"date, segmente, cadre, pachete, biți\",\n\"Answer\": \"c\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Ce afirmații sunt adevărate despre protocolul TCP?\",\n\"Answer1\": \"este un protocol orientat de datagrame\",\n\"Answer2\": \"este un protocol orientat pe conexiune\",\n\"Answer3\": \"nu folosește sume de control\",\n\"Answer4\": \"asigură segmentare și reasamblare\",\n\"Answer\": \"b,d\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Care din următoarele adrese IP se încadrează în blocul CIDR din 115.64.4.0/22? (Alegeti două.)\",\n\"Answer1\": \"115.64.8.32\",\n\"Answer2\": \"115.64.6.255\",\n\"Answer3\": \"115.64.8.31\",\n\"Answer4\": \"115.64.5.128\",\n\"Answer\": \"b,d\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Ce informații sunt conținute de headerul unui frame Ethernet?\",\n\"Answer1\": \"sursa și destinatia adresei de hardware\",\n\"Answer2\": \"sursa și destinatia adresei de rețea\",\n\"Answer3\": \"codul de corectare a erorilor\",\n\"Answer4\": \"codul de autentificare\",\n\"Answer\": \"a\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Care din următoarele afirmații sunt adevărate referitor la switch?\",\n\"Answer1\": \"crează un singur domeniu de coliziune și un singur domeniu de broadcast\",\n\"Answer2\": \"crează diferite domenii de coliziune dar un singur domeniu de broadcast\",\n\"Answer3\": \"crează diferite domenii de coliziune și diferite domenii de broadcast\",\n\"Answer\": \"b\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Care din următoarele adrese IP este un exemplu valid de adresă IPv4?\",\n\"Answer1\": \"144.92.254.253\",\n\"Answer2\": \"144-92-43-178\",\n\"Answer3\": \"144.92.256.176\",\n\"Answer4\": \"144,92,43,178\",\n\"Answer\": \"a\",\n\"Category\": \"Rețele de calculatoare\"\n},\n{\n\"QuestionTitle\": \"Care este semnificația acronimului CSMA/CD?\",\n\"Answer1\": \"Carrier Service Multiple Access with Collision Detection\",\n\"Answer2\": \"Carrier Sense Multiple Access with Collision Avoidance\",\n\"Answer3\": \"Carrier Sense Multiple Access with Collision Detection\",\n\"Answer4\": \"Control Sense Multiple Access with Collision Direction\",\n\"Answer\": \"c\",\n\"Category\": \"Rețele de calculatoare\"\n}\t  \n]\n";
        
        private IEnumerator<Question> questionEnumerator;

		public QuestionService()
		{
            Questions = GetQuestions(QuestionsPath);
            Questions = Questions.OrderBy(x => new Random().Next()).ToList();
            Questions.ForEach(q => q.SetAnswers());
            questionEnumerator = Questions.GetEnumerator();
		}

        public List<Question> Questions { get; set; }

        public List<Question> GetQuestions(string text)
        {
            return JsonSerializer.Deserialize<List<Question>>(text);
        }

        public Question GetQuestion()
        {
            if (questionEnumerator.MoveNext())
            {
                return questionEnumerator.Current;
            }
            else
            {
                questionEnumerator.Reset();
                return questionEnumerator.Current;
            }
        }

        public async Task<string> DownloadFile(string rawFileUrl)
        {
            var _httpClient = new HttpClient();
            try
            {
                using (var response = await _httpClient.GetAsync(rawFileUrl))
                {
                    response.EnsureSuccessStatusCode();

                    var content = await response.Content.ReadAsStringAsync();
                    Console.WriteLine("File downloaded successfully!");

                    return content;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred while downloading the file: {ex.Message}");
                return null;
            }
        }
    }
}

